<!DOCTYPE html>
<html>
<head>
	<title>Javascript game</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<!--link rel = "icon" href = "minimalLogo.png" type = "image/x-icon"-->
	<link rel = "icon" href = "https://rexdragin59.github.io/circledefense/minimalLogo.png" type = "image/x-icon">
</head>
<body onload = "startGame()">
<div>
	<canvas id="myCanvas" width="600" height="480" style="border: 2px solid black;"></canvas>
	<p id="errorMarquee">Javascript did not compile</p>
	<!-- error marquee is for debugging on mobile -->
	<p style="font-size:30px; user-select: none;">Circle defense game; press (8), (9) to zoom out/in, (0) to reset camera, wasd to pan camera, (p) to toggle pause and also toggle music mute, (o) to toggle debug pause, hold down left mouse button to shoot at enemies</p>
	<p style="font-size:30px; user-select: none;">click translucent red button to upgrade cannon, using cursor to collect coins</p>
	<div id="fpsDisplay" style="user-select: none">FPS:</div>
</div>
<script>

const CANVAS_WIDTH = Math.min(800, screen.width*13/14);	// mobile-friendly
const CANVAS_HEIGHT = Math.min(480, screen.height*13/14);
let canvas = undefined;
let ctx = undefined;
let xCanvas = undefined;
let yCanvas = undefined;
const FPS = 60;
let frame = 0;
let debugFrame = 0;
const UNIVERSAL_LINE_WIDTH = 2;

// constructor
function vec2(x, y, debugId = undefined){
	this.x = x;
	this.y = y;
	this.debugId = debugId;
}

// returns new vec2
vec2.prototype.subtract = function(v)
{
	return new vec2(this.x - v.x, this.y - v.y);
}

// returns new vec2
vec2.prototype.normalize = function()
{
	let len = this.len();
	if (len == 0.0)
	{
		throw 'cannot normalize zero vector';
	}
	return this.mult(1/len);
}

// returns new vec2
vec2.prototype.add = function(v)
{
	return new vec2(this.x + v.x, this.y + v.y);
}

// returns new vec2
vec2.prototype.mult = function(c)
{
	return new vec2(this.x*c, this.y*c);
}

vec2.prototype.len = function()
{
	return Math.sqrt(this.len_sq());
}

vec2.prototype.len_sq = function()
{
	return vec2.dot(this, this);
}

vec2.dot = function(v1, v2)
{
	return v1.x*v2.x + v1.y*v2.y;
}

// 2d scalar cross product
vec2.cross = function(v1, v2)
{
	return v1.x*v2.y - v2.x*v1.y;
}

// args are vec2 objects
// returns boolean
const MIN_SIN = 1e-9;
// will throw error in vec2.normalize if zero vector is one of the args
vec2.is_parallel = function(v1, v2){
	let v1n = v1.normalize();
	let v2n = v2.normalize();
	return Math.abs( v1n.x*v2n.y - v1n.y*v2n.x ) < MIN_SIN;	// normalize first to minimize influence of vector length on parallel result
//	return Math.abs(v1.x*v2.y - v2.x*v1.y) < MIN_VEC_LEN;
	// ERROR PREVIOUSLY HERE: crossProd(v1, v2) == zero if parallel vectors OR if one (or both) vectors have very small length
}

const MIN_VEC_LEN = 1e-9;
vec2.is_same_loc = function(v1, v2)
{
	// hopefully more robust against floating point error than [(v1-v2).len_sq() == 0]
	return v1.subtract(v2).len_sq() < MIN_VEC_LEN*MIN_VEC_LEN;
}

vec2.prototype.is_zero = function()
{
	return vec2.is_same_loc(this, new vec2(0, 0));
}

// returns new vec2 equal to *this* vec2 rotate theta radians about origin
vec2.prototype.rotate = function(theta)
{
	let COS = Math.cos(theta);
	let SIN = Math.sin(theta);
	return new vec2(this.x*COS - this.y*SIN, this.x*SIN + this.y*COS);
}

// returns same geometric vector in new memory location
vec2.prototype.clone = function()
{
	return new vec2(this.x, this.y);
}

const VERTEX_RADIUS = 4;
vec2.prototype.render_solid = function(colorStr, radius = VERTEX_RADIUS)
{
	ctx.fillStyle = colorStr;
	ctx.beginPath();
	ctx.arc(this.x, this.y, radius, 0, 2*Math.PI);
	ctx.fill();
}

vec2.prototype.render_ring = function(colorStr, radius = VERTEX_RADIUS)
{
	ctx.strokeStyle = colorStr;
	ctx.beginPath();
	ctx.arc(this.x, this.y, radius, 0, 2*Math.PI);
	ctx.stroke();
}

// render text at arg world coords
vec2.prototype.render_text = function(textStr, colorStr)
{
	ctx.fillStyle = colorStr;
	ctx.fillText(textStr, this.x, this.y);
}

// since console.log(Vertex) doesn't always display correct values
vec2.prototype.toString = function()
{
	return '(('.concat(this.x, ', ', this.y, '); id=', (this.debugId != undefined ? this.debugId : ''), ')');
}

// only renders debugId text; does NOT render vertex itself
vec2.prototype.render_debug_id = function(colorStr)
{
	this.render_offset_legend_text(this.debugId, colorStr, get_legend_offset(this.debugId.toString()));
}

// constructor
function LineSeg(r1, r2, debugId = undefined)
{
	this.r1 = r1;
	this.r2 = r2;
	this.debugId = debugId;
}
LineSeg.prototype.render = function(colorStr, radius = undefined)
{
	ctx.strokeStyle = colorStr;
	ctx.beginPath();
	ctx.moveTo(this.r1.x, this.r1.y);
	ctx.lineTo(this.r2.x, this.r2.y);
	ctx.stroke();
	if (radius != undefined)
	{
		this.r1.render_solid(colorStr, radius);
		this.r2.render_solid(colorStr, radius);
	}
}

// render positive&negative [sawtooth wave with arg num periods], similar to sin wave, along *this* LineSeg to distinguish from other collinear line segs
// nPeriods is positive integer or positive half-[odd integer]
// amplitude radio is amplitude/lineSegLength
LineSeg.prototype.render_saw = function(colorStr = '#000000FF', nPeriods = 10, amplitudeRatio = 1/35.4, vertexRadius1 = undefined, vertexRadius2 = undefined){
	const lineDirec = this.r2.subtract(this.r1);
	if (amplitudeRatio == undefined){
		amplitudeRatio = lineDirec.len()/35.4;
	}
	normal = lineDirec.mult(amplitudeRatio);	// euclidean length == amplitude
	normal = new vec2(normal.y, -normal.x);
	
	const SAW_START_PROGRESS = 0.1;	// begin sawtooth at a distance from vertex, to display correct lineseg angle near vertex
	let nHumps = Math.floor(2*nPeriods);
	let progressArr = new Array(nHumps).fill(0).map( (val, index) => (index+0.5)/nHumps*(1-2*SAW_START_PROGRESS)+SAW_START_PROGRESS );	// linearly interpolate [evenly-distributed progress] between (SAW_START_PROGRESS) and (1-SAW_START_PROGRESS)
	
	ctx.strokeStyle = colorStr;
	ctx.beginPath();
	ctx.moveTo(this.r1.x, this.r1.y);
	let vSawStart = lineDirec.mult(SAW_START_PROGRESS).add(this.r1);
	ctx.lineTo(vSawStart.x, vSawStart.y);
	for(let i = 0; i < progressArr.length; ++i)
	{
		let v = lineDirec.mult(progressArr[i]).add(this.r1).add(normal.mult(i % 2 == 0 ? 1 : -1));
		ctx.lineTo(v.x, v.y);
	}
	let vSawEnd = lineDirec.mult(1-SAW_START_PROGRESS).add(this.r1);
	ctx.lineTo(vSawEnd.x, vSawEnd.y);
	ctx.lineTo(this.r2.x, this.r2.y);
	ctx.stroke();
	
	if (vertexRadius1 != undefined)
	{
		this.r1.render_ring(colorStr, vertexRadius1);
		if (vertexRadius2 != undefined){
			this.r2.render_ring(colorStr, vertexRadius2);
		}else{
			this.r2.render_ring(colorStr, vertexRadius1);
		}
	}
}

LineSeg.prototype.toString = function()
{
	return '( '.concat(this.r1.toString(), ' to ', this.r2.toString(), '; id=', (this.debugId != undefined ? this.debugId : ''), ' )');
}

// lehmer linear congruential generator
// returns nArgs psuedorandom numbers uniformly distributed in [0, 1)
// m is prime, and multiplier is largest int (mod m) with largest multiplicative order mod m
// by design, seed is coprime to RNG_MOD
const RNG_MULTIPLIER = 134;
const RNG_MOD = 137;
const RNG_OFFSET = 8;	// 2^RNG_OFFSET > RNG_MOD
function rng(seedStr, nArgs = 1)
{
	if (nArgs <= 0){
		throw 'cannot generate non-positive quantity of random numbers';
	}
	
	// convert seedStr to hash mod RNG_MOD
	let powMod = 1;
	let hash = seedStr.charCodeAt(0);
	for(let i = 1; i < seedStr.length; ++i)
	{
		powMod = (128*powMod) % RNG_MOD;
		hash += seedStr.charCodeAt(i)*powMod;	// hash = s[0] + s[1]*128^1 + s[2]*128^2 + s[3]*128^3 + ... + s[n]*128^n (mod RNG_MOD)
		// 128 because alphabet ascii is in range [32, 126]
	}
	let x = hash % RNG_MOD;	// seed
	
	// offset a fixed number of terms in order to countert initial predictability
	for(let i = 0; i < RNG_OFFSET; ++i){
		x = x*RNG_MULTIPLIER % RNG_MOD;
	}
	
	let rNums = [];
	for(let i = 0; i < nArgs; ++i){
		x = x*RNG_MULTIPLIER % RNG_MOD;
		rNums.push(x);
	}
	
	return rNums.map(x => x/RNG_MOD);
}

function lerp(a, b, x)
{
	return a*(1-x) + b*x;
}

// returns float uniformly distributed in [minimum, maximum)
function rnd_btwn(minimum, maximum)
{
	return (maximum-minimum)*Math.random() + minimum;
}

// compute pseudorandom random unit vector seeded by seedStr, oscillating in angle via two sinusoids, based on current frame
// returns vec2
function get_legend_offset(seedStr)
{
	const LEGEND_OFFSET_DIST = 38;
	const MIN_OMEGA_1 = 0.006;
	const MAX_OMEGA_1 = 0.007;
	const MIN_OMEGA_2 = 0.011;
	const MAX_OMEGA_2 = 0.012;
	let [r1, r2, r3, r4] = rng(seedStr, 4);
	let [w1, w2, phi1, phi2] = [lerp(MIN_OMEGA_1, MAX_OMEGA_1, r1), lerp(MIN_OMEGA_2, MAX_OMEGA_2, r2), lerp(0, 2*Math.PI, r3), lerp(0, 2*Math.PI, r4)];
	let theta = lerp(0, 2*Math.PI, 0.5*(Math.sin(w1*debugFrame + phi1) + Math.sin(w2*debugFrame + phi2)) + 1);
	return new vec2(Math.cos(theta), Math.sin(theta)).mult(LEGEND_OFFSET_DIST);
}

// render text offset by offsetVec (in onscreen pixel coords)
// and render thin lineSeg connecting *this* vector and text location
vec2.prototype.render_offset_legend_text = function(textStr, colorStr = '#000000FF', offsetVec = undefined)
{
	let v2 = this.add(offsetVec != undefined ? offseVec : new vec2(0, 0));
	v2.render_text(textStr, colorStr);

	const TEXT_LEGEND_LINE_WIDTH = 0.9;
	ctx.lineWidth = TEXT_LEGEND_LINE_WIDTH;
	new LineSeg(this, v2).render(colorStr);
	ctx.lineWidth = UNIVERSAL_LINE_WIDTH;
};

// render debugId and midpoint ONLY; do not render endpoints nor lineSeg
LineSeg.prototype.render_debug_id = function(colorStr = '#000000FF')
{
	let mid = this.r1.add(this.r2).mult(0.5);
	const lineDirec = this.r2.subtract(this.r1);
	if (vec2.is_same_loc(lineDirec, new vec2(0, 0)))	// if lineSeg is single point, then no normal line segment jutting out
	{
		mid.render_text(this.debugId, colorStr);
	}
	else
	{
		const MIDPOINT_RADIUS = 3.5;
		mid.render_solid(colorStr, MIDPOINT_RADIUS);
		mid.render_offset_legend_text(this.debugId, colorStr, get_legend_offset(this.debugId.toString()));
	}
}

// constructor
function Rect(x, y, w, h)
{
	this.x = x;
	this.y = y;
	this.w = w;
	this.h = h;
}

Rect.prototype.contains_xy = function(x, y, isBorderIncluded = true)
{
	if (isBorderIncluded)
	{
		return x >= this.x &&
			   x <= this.x + this.w &&
			   y >= this.y &&
			   y <= this.y + this.h;
	}
	return x > this.x &&
		   x < this.x + this.w &&
		   y > this.y &&
		   y < this.y + this.h;
}

Rect.prototype.contains_vec2 = function(v, isBorderIncluded = true)
{
	return this.contains_xy(v.x, v.y, isBorderIncluded);
}


// returns an Image(), possibly not yet loaded
function load_image(filepath){
	var img = document.createElement("img");
	img.src = filepath;
	img.onload = function(){
		img.isLoaded = true;
	};
	img.isLoaded = false;	// custom member
	return img;
}

// Blit an image to the canvas
// alpha is a float in the range [0, 1]
function apply_image(img, x, y, alpha = 1.0){
	if (img.isLoaded || img instanceof HTMLCanvasElement){
		if (alpha == 1.0){
			ctx.drawImage(img, x, y);
		}else{
			let cv = document.createElement("canvas");
			cv.width = img.width;
			cv.height = img.height;
			
			let cx = cv.getContext("2d");
			cx.globalAlpha = alpha;
			cx.drawImage(img, 0, 0);
			ctx.drawImage(cv, x, y);	// must render to a 2nd canvas and then render the 2nd canvas to the screen, since globalAlpha is the only way to use transparency
		}
	}else{
		throw "cannot draw non-loaded image!";
	}
}

// Blit frontImg onto rearImg with frontImg's alpha in the range [0, 1]
// if srcRect is undefined, then blit [the entire frontImg] onto rearImg
// returns new image
function apply_image_to_image(frontImg, rearImg, alpha, srcRect, dstRect){
	if (!(frontImg.isLoaded || frontImg instanceof HTMLCanvasElement) || !(rearImg.isLoaded || rearImg instanceof HTMLCanvasElement)){
		throw "cannot draw non-loaded image!";
	}
		
	let cv = document.createElement("canvas");
	cv.width = rearImg.width;
	cv.height = rearImg.height;
	let cx = cv.getContext("2d");
	cx.drawImage(rearImg, 0, 0);
	if (alpha > 0.0){
		cx.globalAlpha = alpha;
		if (srcRect != undefined){
			cx.drawImage(frontImg, srcRect.x, srcRect.y, srcRect.w, srcRect.h, dstRect.x, dstRect.y, dstRect.w, dstRect.h);
		}else{
			cx.drawImage(frontImg, dstRect.x, dstRect.y, dstRect.w, dstRect.h);
		}
	}
	return cv;
}

// apply image to screen with alpha in [0, 1]
// must specify srcRect and dstRect
function apply_image_precise(img, alpha, srcRect, dstRect){
	if (img.isLoaded || img instanceof HTMLCanvasElement){
		if (alpha == 1.0){
			ctx.drawImage(img, srcRect.x, srcRect.y, srcRect.w, srcRect.h, dstRect.x, dstRect.y, dstRect.w, dstRect.h);
		}else if(alpha > 0.0){
			let cv = document.createElement("canvas");
			cv.width = img.width;
			cv.height = img.height;
			
			let cx = cv.getContext("2d");
			cx.globalAlpha = alpha;
			cx.drawImage(img, 0, 0);
			ctx.drawImage(cv, srcRect.x, srcRect.y, srcRect.w, srcRect.h, dstRect.x, dstRect.y, dstRect.w, dstRect.h);
		}
	}else{
		throw "cannot draw non-loaded image!";
	}
}

// Blit frontImg onto rearImg with frontImg's alpha in the range [0, 1]
// returns temporary new image
//     "temporary" meaning the returned image is reset each time you call apply_image_to_image_temp()
// doesn't affect original frontImg nor rearImg
// if rearOnlyDst is true, result is only the portion of the combined image delineated by dstRect, including [area in frontImg but not in rearImg]
// if rearOnlyDst is false, result is the entire combined image
function apply_image_to_image_temp(frontImg, rearImg, alpha, srcRect, dstRect, rearOnlyDst = false){
	if (!(frontImg.isLoaded || frontImg instanceof HTMLCanvasElement) || !(rearImg.isLoaded || rearImg instanceof HTMLCanvasElement)){
		throw "cannot draw non-loaded image!";
	}
	if (rearOnlyDst){
		tempCv.width = dstRect.w;
		tempCv.height = dstRect.h;
		tempCx.globalAlpha = 1.0;
		tempCx.drawImage(rearImg, 0, 0);
		tempCx.globalAlpha = alpha;
		tempCx.drawImage(frontImg, srcRect.x, srcRect.y, srcRect.w, srcRect.h, 0, 0, dstRect.w, dstRect.h);
	}else{
		tempCv.width = rearImg.width;
		tempCv.height = rearImg.height;
		tempCx.globalAlpha = 1.0;
		tempCx.drawImage(rearImg, 0, 0);
		tempCx.globalAlpha = alpha;
		tempCx.drawImage(frontImg, srcRect.x, srcRect.y, srcRect.w, srcRect.h, dstRect.x, dstRect.y, dstRect.w, dstRect.h);
	}
	return tempCv;
}

function convert_image_to_canvas(img){
	if (img instanceof HTMLCanvasElement){
		return img;
	}else if(!img.isLoaded){
		throw "cannot convert non-loaded image to canvas!";
	}
	
	var cv = document.createElement("canvas");	// use this canvas instead of creating a new canvas every time you blit transparency
	cv.width = img.width;
	cv.height = img.height;
	var cx = cv.getContext("2d");
	cx.drawImage(img, 0, 0);
	return cv;
}

function calculate_canvas_corner()
{
	let rect = canvas.getBoundingClientRect();
	xCanvas = rect.x;
	yCanvas = rect.y;
}


// constructor
// simple polygon of either counterclockwise or clockwise winding
// arg vertices is array of vec2 objects
function Polygon(vertices)
{
	if (vertices.length < 3){
		throw 'cannot have polygon with only '.concat(vertices.length, ' vertices; need at least 3');
	}
	this.vertices = vertices.slice();	// clone
}


// render line segs only, not vertices nor debugIds
Polygon.prototype.render = function(lineColorStr = undefined, fillColorStr = undefined)
{
	if (lineColorStr == undefined && fillColorStr == undefined)
	{
		lineColorStr = '#FF0000FF';
	}
	
	ctx.beginPath();
	for(let i = 0; i < this.vertices.length+1; ++i){
		let i1 = i % this.vertices.length;
		if (i == 0)
		{
			ctx.moveTo(this.vertices[i].x, this.vertices[i].y);
		}
		else
		{
			ctx.lineTo(this.vertices[i1].x, this.vertices[i1].y);
		}
	}
	if (lineColorStr != undefined)
	{
		ctx.strokeStyle = lineColorStr;
		ctx.stroke();
	}
	
	if (fillColorStr != undefined){
		ctx.fillStyle = fillColorStr;
		ctx.fill();
	}
}

// return new rotated Poylgon; center is vec2
Polygon.prototype.rotate = function(thetaRad, center)
{
	return new Polygon(this.vertices.map(function(v){
		let v1 = v.subtract(center);
		let xR = v1.x*Math.cos(thetaRad) - v1.y*Math.sin(thetaRad);
		let yR = v1.x*Math.sin(thetaRad) + v1.y*Math.cos(thetaRad);
		return new vec2(xR, yR).add(center);
	}));
}

// return new translated polygon
Polygon.prototype.translate = function(offsetVec)
{
	return new Polygon(this.vertices.map(v => v.add(offsetVec)));
}

// return new scaled polygon
Polygon.prototype.scale = function(scale)
{
	return new Polygon(this.vertices.map(v => v.mult(scale)));
}

// render debugIds ONLY; do not render polygon vertices nor polygon lineSegs nor polygon fill
Polygon.prototype.render_debug_ids = function(colorStr = '#DD00CCFF')
{
	for(let i in this.vertices)
	{
		this.vertices[i].render_text(v.debugId, GREY);
	}
}

// returns Polygon object
Polygon.create_polygon_from_rect = function(rect)
{
	return new Polygon([new vec2(rect.x, rect.y),
						new vec2(rect.x+rect.w, rect.y),
						new vec2(rect.x+rect.w, rect.y+rect.h),
						new vec2(rect.x, rect.y+rect.h)]);
}

// returns boolean whether *this* and arg Polygon are intersecting
// assumes *this* and arg poly are convex polygons
Polygon.prototype.is_intersecting_convex_polygon = function(poly)
{
	return this.vertices.map((v, i) => {
		let i1 = (i+1) % this.vertices.length;
		let axis = v.subtract(this.vertices[i1]).rotate(Math.PI/2);
		return axis;
	}).concat(
		poly.vertices.map((v, i) => {
			let i1 = (i+1) % poly.vertices.length;
			let axis = v.subtract(poly.vertices[i1]).rotate(Math.PI/2);
			return axis;
		})
	).filter(v => !v.is_zero()).every(axis => {
		let dpSelf = this.vertices.map(v => vec2.dot(v, axis));
		let dpPoly = poly.vertices.map(v => vec2.dot(v, axis));
		let minSelf = Math.min.apply(undefined, dpSelf);
		let maxSelf = Math.max.apply(undefined, dpSelf);
		let minPoly = Math.min.apply(undefined, dpPoly);
		let maxPoly = Math.max.apply(undefined, dpPoly);
		return minSelf <= maxPoly && minPoly <= maxSelf;
	});
}

// assumes *this* is convex polygon
// returns boolean whether *this* and arg ConvexPolygon are intersecting
// assumes circleRadius > 0
Polygon.prototype.is_intersecting_circle = function(circleCenter, circleRadius)
{
	let circleAxis = this.vertices.map(v => {
		let deltaV = v.subtract(circleCenter);
		return {v: deltaV, distSq: deltaV.len_sq()};
	}).reduce((minDistVecObj, vObj) => minDistVecObj.distSq < vObj.distSq ? minDistVecObj : vObj).v;	// axis connecting circle center and [closest point on this polygon to circle center]
	
	return this.vertices.map((v, i) => {
		let i1 = (i+1) % this.vertices.length;
		let axis = v.subtract(this.vertices[i1]).rotate(Math.PI/2);
		return axis;
	}).concat(circleAxis).filter(v => !v.is_zero()).every(axis => {
		axis = axis.normalize();
		let dpSelf = this.vertices.map(v => vec2.dot(v, axis));
		let dpCirc = [1, -1].map(sign => vec2.dot( circleCenter.add( axis.mult(circleRadius*sign) ), axis ) );
		let minSelf = Math.min.apply(undefined, dpSelf);
		let maxSelf = Math.max.apply(undefined, dpSelf);
		let minCirc = Math.min.apply(undefined, dpCirc);
		let maxCirc = Math.max.apply(undefined, dpCirc);
		return minSelf <= maxCirc && minCirc <= maxSelf;
	});
}

function* gen_id(startIndex = 0, prefix = undefined)
{
	for(let i = startIndex; true; ++i)
	{
		yield (prefix != undefined ? prefix : '').concat(i);
	}
}

// base class constructor
function Particle()
{
	this.debugId = Particle.particleIdGen.next().value;
}
Particle.particleIdGen = gen_id(0);	// static member

Particle.prototype.is_dead = function()
{
	throw "un-overridden abstract base class method is_dead()";
}

Particle.prototype.get_y_priority = function()
{
	throw "un-overridden abstract base class method get_y_priority()";
}

Particle.prototype.update = function()
{
	throw "un-overridden abstract base class method update()";
}

Particle.prototype.render = function()
{
	throw "un-overridden abstract base class method render()";
}

// constructor
// doesn't interact with other Particles
const INITIAL_LIFE = 31;
const FRICTION = 0.925;
const ANGULAR_FRICTION = 0.945;
function BouncingShape(x, y, vx, vy, omega, polygon){
	Particle.call(this);
	this.pos = new vec2(x, y);
	this.vel = new vec2(vx, vy);
	this.theta = Math.random()*2*Math.PI;
	this.omega = omega;
	this.initPolygon = polygon;
	this.life = INITIAL_LIFE;	// num frames
}
BouncingShape.prototype = Object.create(Particle.prototype);

BouncingShape.prototype.is_dead = function()
{
	return this.life <= 0;
}

BouncingShape.prototype.update = function()
{
	--this.life;
	this.vel = this.vel.mult(FRICTION);
	this.omega *= ANGULAR_FRICTION;

	this.pos = this.pos.add(this.vel);
	this.theta += this.omega;
	
	// bounce off walls elastically
	if (this.pos.x < 0){
		this.pos.x *= -1;
		this.vel.x *= -1;
	}
	if (this.pos.y < 0){
		this.pos.y *= -1;
		this.vel.y *= -1;
	}
	if (this.pos.x > CANVAS_WIDTH){
		this.pos.x = CANVAS_WIDTH;
		this.vel.x *= -1;
	}
	if (this.pos.y > CANVAS_HEIGHT){
		this.pos.y = CANVAS_HEIGHT;
		this.vel.y *= -1;
	}
}

BouncingShape.prototype.render = function()
{
	this.initPolygon.rotate(this.theta, new vec2(0, 0)).translate(this.pos).render( 'rgba(125, 25, 74, '.concat(this.life/INITIAL_LIFE, ')') );
}

// constructor
function BouncingStar(x, y, vx, vy, omega, polygon)
{
	BouncingShape.call(this, x, y, vx, vy, omega, polygon);
}
BouncingStar.prototype = Object.create(BouncingShape.prototype);

BouncingStar.prototype.get_y_priority = function()
{
	return this.pos.y;
}

BouncingStar.prototype.render = function()
{
	const NUM_LAYERS = 7;
	for(let i = 0; i < NUM_LAYERS-1; ++i)
	{
		let param = i/(NUM_LAYERS-1);
		let color = `hsla(${lerp(21, 50.0, param)}, 100%, 50%, ${this.life/INITIAL_LIFE})`;	// outer layers are more red than green
		this.initPolygon.rotate(this.theta, new vec2(0, 0)).scale(lerp(1, 0.15, param)**1.3).translate(this.pos).render(undefined, color);
	}
};

BouncingStar.create_star = function(nPoints, x, y, vx, vy, omega, outerRadius = undefined)
{
	if (nPoints == undefined || nPoints < 3){
		throw "cannot create bouncing star with <3 points";
	}

	if (outerRadius == undefined){
		const DEFAULT_OUTER_RADIUS = 20.0;
		outerRadius = DEFAULT_OUTER_RADIUS;
	}
	const INNER_RADIUS = outerRadius*0.6;
	const OUTER_RADIUS = outerRadius;
	let vertices = [];
	for(let i = 0; i < 2*nPoints; ++i)
	{
		let radius = i % 2 == 0 ? OUTER_RADIUS : INNER_RADIUS;
		vertices.push(new vec2(Math.cos(i/2/nPoints*2*Math.PI)*radius, Math.sin(i/2/nPoints*2*Math.PI)*radius));
	}
	let polygon = new Polygon(vertices);
	return new BouncingStar(x, y, vx, vy, omega, polygon);
}

MAX_NUM_PARTICLES = 1000;
// constructor
function ParticleEngine()
{
	this.particles = [];
}

ParticleEngine.prototype.reset_engine = function()
{
	this.particles.splice(0);
}

ParticleEngine.prototype.add_particle = function(particle)
{
	if (this.particles.length >= MAX_NUM_PARTICLES){
		console.log("too many particles; ignored adding another");
	}
	this.particles.push(particle);
}

ParticleEngine.prototype.update = function()
{
	this.particles.forEach(p => p.update());
	this.particles = this.particles.filter(p => !p.is_dead());
}

ParticleEngine.prototype.render = function()
{
	// lower y-position priority gets rendered first, and higher y-position priority gets rendered on top of lower priority Particles
	this.particles.sort((a, b) => a.get_y_priority() - b.get_y_priority()).forEach( p => p.render() );
}

// arg is vec2
ParticleEngine.prototype.create_star_explosion = function(pos)
{
	const NUM_STARS = 5;
	const NUM_STAR_POINTS = 5;
	const MAX_STAR_SPEED = 3.0;
	const MAX_STAR_OMEGA = 0.22;
	const MIN_STAR_OUTER_RADIUS = 4.0;
	const MAX_STAR_OUTER_RADIUS = 14.0;
	for(let i = 0; i < NUM_STARS; ++i)
	{
		let vx = MAX_STAR_SPEED*(Math.random()*2 - 1);
		let vy = MAX_STAR_SPEED*(Math.random()*2 - 1);
		let omega = MAX_STAR_OMEGA*(Math.random()*2-1);
		let outerRadius = rnd_btwn(MIN_STAR_OUTER_RADIUS, MAX_STAR_OUTER_RADIUS);
		let bouncingStar = BouncingStar.create_star(NUM_STAR_POINTS, pos.x, pos.y, vx, vy, omega, outerRadius);
		this.add_particle(bouncingStar);
	}
}

// arg is vec2
ParticleEngine.prototype.create_smoke_puffs = function(pos)
{
	// create smoke at bullet
	const NUM_SMOKE_PUFFS = 3;
	const MAX_SMOKE_PUFF_SPEED = 0.11;
	const MIN_SMOKE_PUFF_RADIUS = 6;
	const MAX_SMOKE_PUFF_RADIUS = 15;
	const MAX_SMOKE_PUFF_OFFSET = 5;
	const MIN_LIFETIME = 50;
	const MAX_LIFETIME = 70;
	for(let i = 0; i < NUM_SMOKE_PUFFS; ++i)
	{
		let dx = MAX_SMOKE_PUFF_OFFSET*(Math.random()*2 - 1);
		let dy = MAX_SMOKE_PUFF_OFFSET*(Math.random()*2 - 1);
		let vx = MAX_SMOKE_PUFF_SPEED*(Math.random()*2 - 1);
		let vy = MAX_SMOKE_PUFF_SPEED*(Math.random()*2 - 1);
		let smokePuffRadius = rnd_btwn(MIN_SMOKE_PUFF_RADIUS, MAX_SMOKE_PUFF_RADIUS);
		let rgbColorStr = `#${Math.floor(rnd_btwn(99, 241)).toString(16).padStart(2, '0').repeat(3)}`;
		let lifeTime = rnd_btwn(MIN_LIFETIME, MAX_LIFETIME);
		let pos1 = pos.add(new vec2(dx, dy));
		let smokePuff = new SmokePuff(pos1, new vec2(vx, vy), smokePuffRadius, rgbColorStr, lifeTime);
		this.add_particle(smokePuff);
	}
}

const NUM_FRAMES_PER_FPS_UPDATE = 20;
let prevFrameTime = 0;
let gamePaused = false;
let mustImmediatePause = false;	// for advancing 1 frame
let debugFlailPaused = false;

let mouseLoc = new vec2(0, 0);	// world coords
let mouseDownLoc;	// vec2; undefined if mouse is not down; world coords
let cannonBarrelRecoilPos = 0.0;
let cannonTheta = Math.PI;	// points upward before mouse moves
const CANNON_X = CANVAS_WIDTH/2;	// center of cannon base
const CANNON_Y = CANVAS_HEIGHT*3/4;
let cannonReloadFramesRemaining = 0;
let particleEngine = new ParticleEngine();
const CANNON_BASE_RADIUS = 40;

// returns boolean whether two moving circles will be intersecting at some time within [0, 1)
// circle centers at time t=0 are p1, p2
// circle velocities are v1, v2
// circle radii are r1, r2
function are_circles_colliding(p1, p2, v1, v2, r1, r2)
{
	// |(p1+v1*t) - (p2+v2*t)|^2 = (r1+r2)^2	is eqn for when dist btwn circle centers equals sum of radii
	// |(p1-p2) + (v1-v2)t|^2 - (r1+r2)^2 = 0
	// |p1-p2|^2 + 2*t*dot(p1-p2, v1-v2) + t^2 *|v1-v2|^2 - (r1+r2)^2 = 0	using dot(a, a) == |a|^2
	// a*t^2 + b*t + c = 0 via quadratic formula, where:
	//		a = |v1-v2|^2
	//		b = 2*dot(p1-p2, v1-v2)
	//		c = |p1-p2|^2 - (r1+r2)^2
	let pp = p1.subtract(p2);
	let vv = v1.subtract(v2);
	let a = vv.len_sq();
	let b = 2*vec2.dot(pp, vv);
	let c = pp.len_sq() - (r1+r2)**2;
	if (a == 0)
	{
		// circles not moving relative to each other
		return c <= 0;
	}
	
	let discriminant = b*b - 4*a*c;
	if (discriminant < 0)
	{
		// circles never intersect at any time t
		return false;
	}
	let t1 = (-b - Math.sqrt(discriminant))/(2*a);
	let t2 = (-b + Math.sqrt(discriminant))/(2*a);
	return t1 < 1 && t2 >= 0;
}

// returns vec2 that is the pro-rated boundary between two circles with centers (p1, p2) and radii (r1, r2)
function get_circle_collision_loc(p1, p2, r1, r2)
{
	if (r1 + r2 == 0)
	{
		return p1;
	}
	return p1.add( p2.subtract(p1).mult(r2/(r1+r2)) );
}

// constructor
// circle with radius, at position pos, moving with velocity vel
function MovingParticle(pos, vel, radius)
{
	Particle.call(this);
	this.pos = pos.clone();
	this.vel = vel.clone();
	if (radius < 0)
	{
		throw new Error("radius cannot be negative");
	}
	this.radius = radius;
	this.isActive = true;	// can be manually deactivated to request erasure from particle engine
}
MovingParticle.prototype = Object.create(Particle.prototype);

// [still onscreen?]
MovingParticle.prototype.is_dead = function()
{
	return !this.isActive ||
		   this.pos.x < -this.radius ||
		   this.pos.x > CANVAS_WIDTH + this.radius ||
		   this.pos.y < -this.radius ||
		   this.pos.y > CANVAS_HEIGHT + this.radius;
}

MovingParticle.prototype.get_y_priority = function()
{
	return this.pos.y + this.radius;
}

MovingParticle.prototype.update = function()
{
	this.pos.x += this.vel.x;
	this.pos.y += this.vel.y;
}

// constructor
// generic enemy class that specific enemies can subclass
function Enemy(pos, vel, radius)
{
	MovingParticle.call(this, pos, vel, radius);
}
Enemy.prototype = Object.create(MovingParticle.prototype);

// check for collision between moving circle and *this* Enemy
// returns boolean whether arg bullet has collided with *this* enemy
// can override this virtual function to apply visual effects like flashing white/red to indicate damage taken
// can also override this virtual function to deal damage to enemy health
Enemy.prototype.is_colliding_with_moving_circle = function(movingParticle)
{
	return are_circles_colliding(movingParticle.pos, this.pos, movingParticle.vel, this.vel, movingParticle.radius, this.radius);
}

// handle response to colliding with bullet/cannon
// default is one-hit-KO
Enemy.prototype.take_damage = function(atkPower)
{
	this.isActive = false;
}

// constructor
function EnemyCrab(pos, vel, radius)
{
	Enemy.call(this, pos, vel, radius);
	this.startAnimFrame = -99999;	// frame that crab claw pinching animation started
}
EnemyCrab.prototype = Object.create(Enemy.prototype);

// static method returns new EnemyCrab
EnemyCrab.create_random_crab = function()
{
	const MIN_ENEMY_SPEED = 0.6;
	const MAX_ENEMY_SPEED = 1.85;
	const MIN_ENEMY_RADIUS = 25.5;
	const MAX_ENEMY_RADIUS = 35.5;
	const MIN_ENEMY_Y = 130;
	const MAX_ENEMY_Y = 230;
	const MAX_TARGET_OFFSET = 25;
	let radius = Math.random()*(MAX_ENEMY_RADIUS-MIN_ENEMY_RADIUS)+MIN_ENEMY_RADIUS;
	let x = Math.random() < 0.5 ? -radius+1 : CANVAS_WIDTH+radius-1;	// barely onscreen to avoid being deleted immediately
	let y = rnd_btwn(MIN_ENEMY_Y, MAX_ENEMY_Y);
	let pos = new vec2(x, y);
	let targetPos = new vec2(CANNON_X + MAX_TARGET_OFFSET*(Math.random()*2-1), CANNON_Y + MAX_TARGET_OFFSET*(Math.random()*2-1));
	let speed = (MAX_ENEMY_SPEED - MIN_ENEMY_SPEED)*Math.random() + MIN_ENEMY_SPEED;
	let vel = targetPos.subtract(pos).normalize().mult(speed);
	return new EnemyCrab(pos, vel, radius);
}

const TOTAL_ANIM_FRAMES = 20;
EnemyCrab.prototype.is_animating = function()
{
	return frame - this.startAnimFrame < TOTAL_ANIM_FRAMES;
}

EnemyCrab.prototype.update = function()
{
	MovingParticle.prototype.update.call(this);
	const ANIMATE_PROB = 0.020;
	if (!this.is_animating() && Math.random() < ANIMATE_PROB)
	{
		this.startAnimFrame = frame;
	}
}

EnemyCrab.prototype.render = function()
{
	/*
	// render circle hitbox
	const BULLET_FILL_COLOR = '#DD44EE60';
	const BULLET_STROKE_COLOR = 'black';
	this.pos.render_solid(BULLET_FILL_COLOR, this.radius);
	this.pos.render_ring(BULLET_STROKE_COLOR, this.radius);
	*/
	let upperClawTheta = -0.2;
	let lowerClawTheta = 0.2;
	if (this.is_animating())
	{
		let param = (frame - this.startAnimFrame)/TOTAL_ANIM_FRAMES;
		const UPPER_CLAW_MAX_AMPLITUDE = 0.2;
		const LOWER_CLAW_MAX_AMPLITUDE = -0.2;
		upperClawTheta += UPPER_CLAW_MAX_AMPLITUDE*Math.sin(param*Math.PI);
		lowerClawTheta += LOWER_CLAW_MAX_AMPLITUDE*Math.sin(param*Math.PI);
	}
	upperClawTheta *=  this.vel.x >= 0 ? -1 : 1;
	lowerClawTheta *=  this.vel.x >= 0 ? -1 : 1;
	
	// render crab
	let picCenter = new vec2(194.80916, 126.4122);
	let picBottom = new vec2(picCenter.x, picCenter.y+165.49619);
	let worldPosBottom = new vec2(this.pos.x, this.pos.y + this.radius);
	draw_image_align_line_segs(crab, picCenter, this.pos, picBottom, worldPosBottom, this.vel.x < 0);
	
	// render bottom crab claw
	let picTip = new vec2(19.1, 60.1);	// image coords
	let picBase = new vec2(125.4, 138.3);	// image coords
	let midClawTipNormalized = new vec2(.683 * (this.vel.x < 0 ? -1 : 1),  .487); // normalized coords
	let clawBase = new vec2(-0.156 * (this.vel.x < 0 ? -1 : 1), 0.400).mult(this.radius).add(this.pos);	// world coords
	let upperClawTip = midClawTipNormalized.rotate(upperClawTheta).mult(this.radius).add(this.pos);
	draw_image_align_line_segs(crabClawLower, picTip, upperClawTip, picBase, clawBase, this.vel.x >= 0);

	// render top crab claw
	let lowerClawTip = midClawTipNormalized = midClawTipNormalized.rotate(lowerClawTheta).mult(this.radius).add(this.pos);
	picTip = new vec2(10.5, 19.1);	// image coords
	picBase = new vec2(101.0, 131.2);	// image coords
	draw_image_align_line_segs(crabClawUpper, picTip, lowerClawTip, picBase, clawBase, this.vel.x >= 0);
	
	// render small crab claw
	picTip  = new vec2(30, 30);		// image coords
	picBase = new vec2(140, 133);	// image coords
	let clawTip  = new vec2(1.2   * (this.vel.x < 0 ? -1 : 1), -0.262).mult(this.radius).add(this.pos);	// world coords
	clawBase = new vec2(0.756 * (this.vel.x < 0 ? -1 : 1), -0.323).mult(this.radius).add(this.pos);	// world coords
	draw_image_align_line_segs(crabClawWhole, picTip, clawTip, picBase, clawBase, this.vel.x < 0);
}

// constructor
const FROG_JUMP_PERIOD = 120;
const FROG_JUMP_ARC_DURATION = 90;
function EnemyFrog(pos, jumpDisplacement, radius, health)
{
	Enemy.call(this, pos, new vec2(0, 0), radius);
	this.jumpDisplacement = jumpDisplacement;	// vec2 in world coords that frog moves each time it jumps
	this.lastGroundPos = pos.clone();	// position where frog last touched ground, in world coords
	this.isJumping = false;
	this.lastJumpFrame = frame + FROG_JUMP_PERIOD;
	this.groundPos = pos.clone();	// current position projected onto the ground
	this.nHurtFramesRemaining = 0;	// number of frames that this frog will be flashing white
	this.health = health;
}
EnemyFrog.prototype = Object.create(Enemy.prototype);

// static method returns new EnemyFrog
EnemyFrog.create_random_frog = function()
{
	const MIN_ENEMY_RADIUS = 15.5;
	const MAX_ENEMY_RADIUS = 55.5;
	const FROG_HEALTH = 2.1;
	let radius = rnd_btwn(MIN_ENEMY_RADIUS, MAX_ENEMY_RADIUS);
	const MIN_ENEMY_Y = 130;
	const MAX_ENEMY_Y = 230;
	let x = Math.random()*CANVAS_WIDTH;
	let y = -radius+1;	// barely onscreen to avoid being deleted immediately
	const MAX_TARGET_OFFSET = 25;
	let targetPos = new vec2(CANNON_X + MAX_TARGET_OFFSET*(Math.random()*2-1), CANNON_Y + MAX_TARGET_OFFSET*(Math.random()*2-1));
	let pos = new vec2(x, y);
	let jumpDisplacement = targetPos.subtract(pos).mult(0.23);
	return new EnemyFrog(pos, jumpDisplacement, radius, FROG_HEALTH);
}

// [still onscreen?] using groundPos
EnemyFrog.prototype.is_dead = function()
{
	return this.health <= 0.0 || !this.isActive;	// ignore in-bounds calculation, since frog frequently jumps out of bounds
}

EnemyFrog.prototype.get_y_priority = function()
{
	return this.groundPos.y + (417-263.2)/282*this.radius;	// y-position at bottom of feet
}

EnemyFrog.prototype.take_damage = function(atkPower)
{
	const HURT_FLASH_DURATION = 6;
	this.health -= bulletAtkPower;
	this.nHurtFramesRemaining = HURT_FLASH_DURATION;
}

EnemyFrog.prototype.update = function()
{
	if(!this.isJumping && frame >= this.lastJumpFrame + FROG_JUMP_PERIOD)
	{
		this.lastJumpFrame = frame;
		this.isJumping = true;
	}
	
	if (this.isJumping)
	{
		// frog parabolically jumps toward cannon
		const FROG_JUMP_HEIGHT_RATIO = 1.0; // ratio of height between [zeros of parabola and vertex of parabola] and [distance between zeros of parabola]
		// jump of height 1 follows arc x*(a - x)/(a/2)^2, where x=0 and x=a are zeros of upside-down parabola
		let param = (frame - this.lastJumpFrame)/FROG_JUMP_ARC_DURATION;
		this.groundPos = this.lastGroundPos.add( this.jumpDisplacement.mult(param) );
		this.pos = this.groundPos.add( new vec2(0, -FROG_JUMP_HEIGHT_RATIO*this.jumpDisplacement.len()*param*(1-param)*4) );
		this.vel = this.jumpDisplacement.mult(1/FROG_JUMP_ARC_DURATION);
		if (frame >= this.lastJumpFrame + FROG_JUMP_ARC_DURATION)
		{
			this.isJumping = false;
			this.lastGroundPos = this.pos;
		}
	}
	if (this.nHurtFramesRemaining > 0)
	{
		--this.nHurtFramesRemaining;
	}
}

EnemyFrog.prototype.render = function()
{
	let frogPic0 = new vec2(120, 26);	// tip of middle of nose
	let frogPic1 = new vec2(120, 153);	// bottom of middle of belly
	let frogNorm0 = new vec2((247-260.9)/282, (58-263.2)/282);
	let frogNorm1 = new vec2((247-260.9)/282, (320-263.2)/282);
	let shadowNorm0 = new vec2((259-260.9)/282, (307.7-260.9)/282);	// center of shadow
	let shadowDst0 = shadowNorm0.mult(this.radius).add(this.groundPos);
	let standShadowNorm1 = new vec2((428.5-260.9)/282, (307.7-260.9)/282);	// rightmost point of shadow
	const CAMERA_VIEW_FACTOR = Math.SQRT1_2;	// if camera looks down with declination angle theta, then a vertical height h is projected onto one [diagonal pixel orthogonal to camera's line of sight] of length h*sin(theta)
	
	// render hitbox
	if (this.isJumping)
	{
		// render jumping frog's shadow
		let jumpShadowPic0 = new vec2(261/2, 97/2);
		let jumpShadowPic1 = new vec2(261, 97/2);
		let jumpShadowNorm1 = new vec2(standShadowNorm1.x*0.75, standShadowNorm1.y);
		let jumpShadowDst1 = jumpShadowNorm1.mult(this.radius).add(this.groundPos);
		draw_image_align_line_segs(frogJumpShadow, jumpShadowPic0, shadowDst0, jumpShadowPic1, jumpShadowDst1);
		
		// render jumping frog
		let frogJumpDst0 = frogNorm0.mult(this.radius).add(this.pos);
		let frogJumpDst1 = frogNorm1.mult(this.radius).add(this.pos);
		let img = this.nHurtFramesRemaining > 0 ? frogHurtJump : frogJump;	// number of frames that this frog will be flashing white
		draw_image_align_line_segs(img, frogPic0, frogJumpDst0, frogPic1, frogJumpDst1);
	}
	else
	{
		// render standing frog's shadow
		let standShadowPic0 = new vec2(170, 64);
		let standShadowPic1 = new vec2(340, 64);
		let standShadowNorm1 = new vec2((428.5-260.9)/282, (307.7-260.9)/282);	// rightmost point of shadow
		let standShadowDst1 = standShadowNorm1.mult(this.radius).add(this.groundPos);
		draw_image_align_line_segs(frogStandShadow, standShadowPic0, shadowDst0, standShadowPic1, standShadowDst1);
		
		// render standing frog
		let frogStandDst0 = frogNorm0.mult(this.radius).add(this.pos);
		let frogStandDst1 = frogNorm1.mult(this.radius).add(this.pos);
		let img = this.nHurtFramesRemaining > 0 ? frogHurtStand : frogStand;
		draw_image_align_line_segs(img, frogPic0, frogStandDst0, frogPic1, frogStandDst1);
	}
}

// constructor
function Constraint()
{
	// nothing
}

// updates endpoint locations
Constraint.prototype.apply_constraint = function()
{
	throw new Error('must override pure virtual method apply_constraint()');
}

// constructor
// vecContainer is {v: <vec2>} object to simulate C++ pointers
// keeps [endpoints v0 and v1] a fixed distance desiredLen away from each other
function ConstraintStick(vecContainer0, vecContainer1, desiredLen, colorStr)
{
	this.vc0 = vecContainer0;
	this.vc1 = vecContainer1;
	this.desiredLen = desiredLen;
	this.colorStr = colorStr;
}
ConstraintStick.prototype = Object.create(Constraint.prototype);

ConstraintStick.prototype.apply_constraint = function()
{
	if (vec2.is_same_loc(this.vc0.v, this.vc1.v))
	{
		this.vc1.v.x += 0.00001;	// avoid division by zero when normalizing
	}
	let mid = this.vc1.v.add(this.vc0.v).mult(0.5);
	this.vc0.v = mid.add( this.vc0.v.subtract(this.vc1.v).normalize().mult(this.desiredLen/2) );
	this.vc1.v = mid.add( this.vc1.v.subtract(this.vc0.v).normalize().mult(this.desiredLen/2) );
}

// constructor
// snaps vector to fixedPoint
function ConstraintFixedPoint(vecContainer, fixedPoint)
{
	this.vc = vecContainer;
	this.fixedPoint = fixedPoint;
}
ConstraintFixedPoint.prototype = Object.create(Constraint.prototype);

ConstraintFixedPoint.prototype.apply_constraint = function()
{
	this.vc.v = this.fixedPoint.clone();
}

// constructor
function EnemySnake(pos, direc, ropeSegLen)
{
	Enemy.call(this, pos, direc, 0.0);
	this.constraints = [];	// Array of (subclasses of) Constraints
	this.ropeSegLen = ropeSegLen;

	//	set up body vertices
	const NUM_VERTICES = EnemySnake.SNAKE_MESH_WIDTH * EnemySnake.SNAKE_MESH_HEIGHT;
	this.bodyVertices = new Array(NUM_VERTICES).fill(0).map( (v, i) => ({ v: new vec2(100, 100) }) );	// Array of {v: <current vec2 position of vertices>}, for animation
	this.prevVertices = this.bodyVertices.map(vc => vc.v);	// Array of vec2, for verlet integration
	// this.bodyVertices[i].v corresponds to this.prevVertices[i].v for all valid i

	// set up body constraints
	for(let y = 0; y < EnemySnake.SNAKE_MESH_HEIGHT; ++y)
	{
		for(let x = 0; x < EnemySnake.SNAKE_MESH_WIDTH; ++x)
		{
			let i = y*EnemySnake.SNAKE_MESH_WIDTH + x;
			let hasRightVertex = x < EnemySnake.SNAKE_MESH_WIDTH-1;
			let hasLeftVertex = x > 0;
			let hasLowerVertex = y < EnemySnake.SNAKE_MESH_HEIGHT-1;
			let hasLower2Vertex = y < EnemySnake.SNAKE_MESH_HEIGHT-2;
			if (hasRightVertex)
			{
				let j = i + 1;	// rightward
				this.constraints.push( new ConstraintStick( this.bodyVertices[i], this.bodyVertices[j], lerp(this.ropeSegLen, 0, y/EnemySnake.SNAKE_MESH_HEIGHT), 'yellow' ) );
			}
			if (hasLowerVertex)
			{
				let k = i + EnemySnake.SNAKE_MESH_WIDTH;	// downward
				this.constraints.push( new ConstraintStick( this.bodyVertices[i], this.bodyVertices[k], lerp(this.ropeSegLen, 0, y/EnemySnake.SNAKE_MESH_HEIGHT), 'yellow' ) );
			}
			if (hasRightVertex && hasLowerVertex)
			{
				let k1 = (y+1)*EnemySnake.SNAKE_MESH_WIDTH + 1;	// down diagonal
				this.constraints.push( new ConstraintStick( this.bodyVertices[i], this.bodyVertices[k1], lerp(this.ropeSegLen, 0, y/EnemySnake.SNAKE_MESH_HEIGHT), 'yellow' ) );
			}
			if (hasLeftVertex && hasLowerVertex)
			{
				let k0 = (y+1)*EnemySnake.SNAKE_MESH_WIDTH + (x-1);
				this.constraints.push( new ConstraintStick( this.bodyVertices[i], this.bodyVertices[k0], lerp(this.ropeSegLen*Math.sqrt(3), 0, y/EnemySnake.SNAKE_MESH_HEIGHT), 'red' ) );
			}
			if (hasRightVertex && hasLower2Vertex)
			{
				// keep adjacent equilateral triangles from inverting parity
				let k2 = (y+2)*EnemySnake.SNAKE_MESH_WIDTH + x+1;
				this.constraints.push( new ConstraintStick( this.bodyVertices[i], this.bodyVertices[k2], lerp(this.ropeSegLen*Math.sqrt(3), 0, y/EnemySnake.SNAKE_MESH_HEIGHT), 'red' ) );
			}
		}
	}
	this.neckLeftConstraint = new ConstraintFixedPoint(this.bodyVertices[0], new vec2(0, 0));	// fixed point constraint
	this.constraints.push(this.neckLeftConstraint);
	this.neckRightConstraint = new ConstraintFixedPoint(this.bodyVertices[1], new vec2(0, 0));
	this.constraints.push(this.neckRightConstraint);
	this.headPos = new vec2(0, 0);	// head position including oscillation
	this.headVel = new vec2(0, 0);	// for pre-update collision calculation ONLY, not for updating position
	
	if (direc.is_zero())
	{
		throw new Error('cannot initialize EnemySnake using zero direction vector');
	}
	this.headDirec = direc;	// most recent nonzero normalized head direction
	const SNAKE_HEALTH = 3.5;
	this.health = SNAKE_HEALTH;
	
	const SNAKE_INITIAL_NUM_WAYPOINTS = 4;
	this.nWayPointsRemaining = SNAKE_INITIAL_NUM_WAYPOINTS;
	this.waypoint = this.get_next_waypoint();	// vec2
}

EnemySnake.prototype = Object.create(Enemy.prototype);
EnemySnake.SNAKE_MESH_WIDTH = 2;
EnemySnake.SNAKE_MESH_HEIGHT = 20;
EnemySnake.NOSE_LEN_RATIO = 1.5;

EnemySnake.create_random_snake = function()
{
	const SNAKE_ROPE_LEN = 15;
	if (Math.random() < 0.5)
	{
		return new EnemySnake(new vec2(CANVAS_WIDTH, CANVAS_HEIGHT*2/9), new vec2(-1, 0), SNAKE_ROPE_LEN);
	}
	else
	{
		return new EnemySnake(new vec2(0, CANVAS_HEIGHT/8), new vec2(1, 0), SNAKE_ROPE_LEN);
	}
}

// returns vec2
EnemySnake.prototype.get_next_waypoint = function()
{
	if (this.nWayPointsRemaining <= 0)
	{
		return new vec2(CANNON_X, CANNON_Y);
	}
	
	const NUM_ATTEMPTS = 100;
	const MIN_DIST_AWAY = Math.max(CANVAS_WIDTH, CANVAS_HEIGHT)/2;
	for(let i = 0; i < NUM_ATTEMPTS; ++i)
	{
		let waypoint = new vec2(Math.random()*CANVAS_WIDTH, Math.random()*CANVAS_HEIGHT*3/9);
		if (waypoint.subtract(this.pos).len_sq() >= MIN_DIST_AWAY*MIN_DIST_AWAY)
		{
			return waypoint;
		}
	}
	throw new Error('failed to generate snake waypoint');
}

EnemySnake.prototype.take_damage = function(atkPower)
{
	const HURT_FLASH_DURATION = 6;
	this.health -= bulletAtkPower;
	this.nHurtFramesRemaining = HURT_FLASH_DURATION;
}

EnemySnake.prototype.is_dead = function()
{
	return !this.isActive || this.health <= 0.0;
}

EnemySnake.prototype.get_y_priority = function()
{
	return this.pos.y;
}

EnemySnake.prototype.is_colliding_with_moving_circle = function(movingCircle)
{
	let headRadius = this.ropeSegLen*EnemySnake.NOSE_LEN_RATIO/2;
	let headCenter = this.headPos.add(this.headDirec.mult(headRadius));
	if (are_circles_colliding(headCenter, movingCircle.pos, this.headVel, movingCircle.vel, headRadius, movingCircle.radius) )
	{
		return true;
	}
	
	// check collision against snake triangles
	for(let y = 0; y < EnemySnake.SNAKE_MESH_HEIGHT-1; ++y)
	{
		// assume triangle doesn't change shape or rotate and has const velocity throughout timestep, for purposes of bullet collision
		let v0 = this.bodyVertices[y*EnemySnake.SNAKE_MESH_WIDTH].v;
		let v1 = this.bodyVertices[y*EnemySnake.SNAKE_MESH_WIDTH+1].v;
		let v2 = this.bodyVertices[(y+1)*EnemySnake.SNAKE_MESH_WIDTH].v;
		let v3 = this.bodyVertices[(y+1)*EnemySnake.SNAKE_MESH_WIDTH+1].v;
		let velA = v0.subtract(this.prevVertices[y])
			  .add(v1).subtract(this.prevVertices[y+1])
			  .add(v3).subtract(this.prevVertices[y+EnemySnake.SNAKE_MESH_WIDTH])
			  .mult(1/3);	// average of triangle vertices' velocities
	    let velB = v0.subtract(this.prevVertices[y+1])
			  .add(v2).subtract(this.prevVertices[y+EnemySnake.SNAKE_MESH_WIDTH])
			  .add(v3).subtract(this.prevVertices[y+EnemySnake.SNAKE_MESH_WIDTH+1])
			  .mult(1/3);	// average of triangle vertices' velocities
		let vRelA = movingCircle.vel.subtract(velA);  // velocity of moving circle relative to this triangle
		let vRelB = movingCircle.vel.subtract(velB);
		
		// test triangles again startCircle, endCircle, and sweptRectangle
		if (new Polygon([v0, v1, v3]).is_intersecting_circle(movingCircle.pos, movingCircle.radius) ||
			new Polygon([v0, v2, v3]).is_intersecting_circle(movingCircle.pos, movingCircle.radius) )
		{
			return true;
		}
		
		if (!movingCircle.vel.is_zero())
		{
			if (new Polygon([v0, v1, v3]).is_intersecting_circle(movingCircle.pos.add(movingCircle.vel), movingCircle.radius) ||
				new Polygon([v0, v2, v3]).is_intersecting_circle(movingCircle.pos.add(movingCircle.vel), movingCircle.radius) )
			{
				return true;
			}
			
			let perp = movingCircle.vel.rotate(Math.PI/2).normalize().mult(movingCircle.radius);
			let rectPoly = new Polygon([movingCircle.pos.add(perp),
										movingCircle.pos.add(movingCircle.vel).add(perp),
										movingCircle.pos.add(movingCircle.vel).subtract(perp),
										movingCircle.pos.subtract(perp)]);
			if (new Polygon([v0, v1, v3]).is_intersecting_convex_polygon(rectPoly) ||
				new Polygon([v0, v2, v3]).is_intersecting_convex_polygon(rectPoly) )
			{
				return true;
			}
		}
	}
	return false;
}

EnemySnake.prototype.update = function()
{
	// compute next waypoint if needed
	const WAYPOINT_RADIUS = 20.0;
	if (are_circles_colliding(this.pos, this.waypoint, this.vel, new vec2(0, 0), 0.0, WAYPOINT_RADIUS))
	{
		--this.nWayPointsRemaining;
		this.waypoint = this.get_next_waypoint();
	}
	
	// move snake head
	const SNAKE_MAX_SPEED = 3.3;
	const SNAKE_ACCEL_FACTOR = 0.02;
	let headAccel = this.waypoint.subtract(this.pos).normalize().mult(SNAKE_MAX_SPEED).subtract(this.vel).mult(SNAKE_ACCEL_FACTOR);
	this.pos = this.pos.add(this.vel).add(headAccel.mult(0.5));
	this.vel = this.vel.add(headAccel);
	
	// set neck constraints
	const OSCILLATION_OMEGA = 0.124;
	this.headDirec = vec2.is_same_loc(new vec2(0, 0), this.vel) ? this.headDirec : this.vel.normalize();
	
	const OSCILLATION_AMPLITUDE_VEC = this.headDirec.mult(this.ropeSegLen*2).rotate(Math.PI/2);
	let headRL = this.headDirec.rotate(Math.PI/2 - Math.PI/6).mult(this.ropeSegLen);	// body is tilted at 30 degrees away from head direction by default, due to constraint geometry
	this.headPos = this.pos.add( OSCILLATION_AMPLITUDE_VEC.mult(Math.sin(OSCILLATION_OMEGA*frame)) );
	this.headVel = OSCILLATION_AMPLITUDE_VEC.mult(Math.cos(OSCILLATION_OMEGA*frame)*OSCILLATION_OMEGA).add(this.vel);
	this.neckLeftConstraint .fixedPoint = this.headPos.add(headRL.mult(-0.5));
	this.neckRightConstraint.fixedPoint = this.headPos.add(headRL.mult( 0.5));
	
	// run verlet integrator
	let GRAVITY_MAG = 0.71;
	let gravity = this.headDirec.mult(-GRAVITY_MAG);	// directional gravity makes tail swish in S-shape instead of flopping wildly
	const FRICTION = 0.0009;	// fraction of velocity to take away every frame; prevents runaway energy
	this.bodyVertices.forEach((vc, i) => {
		let v = vc.v;
		let posCopy = v;
		let vel = v.subtract(this.prevVertices[i]);
		let friction = vel.mult(-FRICTION*vel.len()**(1));	// faster objects slow down more than slower objects
		if ( vel.len_sq() < friction.len_sq() && !vec2.is_same_loc(vel, new vec2(0, 0) ) )
		{
			// friction can never overpower velocity
			friction = friction.normalize().mult(vel.len());
		}
		
		let force = gravity.add( friction );
		vc.v = v.mult(2).subtract(this.prevVertices[i]).add(force.mult(1*1));
		this.prevVertices[i] = posCopy.clone();
	});
	
	// gauss-seidel method of relaxation to converge to [solution that satisfies all constraints at the same time]
	const NUM_CONSTRAINT_ITERATIONS = 5;	// forward once and backward once count as two iterations total
	for(let i = 0; i < NUM_CONSTRAINT_ITERATIONS; ++i)
	{
		this.constraints.forEach(c => c.apply_constraint());
	}
	
	if (this.nHurtFramesRemaining > 0)
	{
		--this.nHurtFramesRemaining;
	}
}

const SNAKE_HEAD_PARAM = -1;
EnemySnake.prototype.get_triangle_color = function(nTrianglesRendered)
{
	const SNAKE_COLOR_LIGHT = '#55EE44FF';
	const SNAKE_COLOR_DARK = '#33AA22FF';
	const SNAKE_COLOR_LIGHT_HURT = '#CCFFBBFF';
	const SNAKE_COLOR_DARK_HURT = '#55CC66FF';
	if (nTrianglesRendered == SNAKE_HEAD_PARAM)
	{
		return this.nHurtFramesRemaining > 0 ? SNAKE_COLOR_LIGHT_HURT : SNAKE_COLOR_LIGHT;
	}
	
	if (this.nHurtFramesRemaining > 0)
	{
		return nTrianglesRendered % 3 == 1 ? SNAKE_COLOR_DARK_HURT : SNAKE_COLOR_LIGHT_HURT;
	}
	else
	{
		return nTrianglesRendered % 3 == 1 ? SNAKE_COLOR_DARK : SNAKE_COLOR_LIGHT;
	}
}

EnemySnake.prototype.render = function()
{
	// render snake body
	const SNAKE_COLOR_LIGHT = '#55EE44FF';
	const SNAKE_COLOR_DARK = '#33AA22FF';
	const SNAKE_COLOR_LIGHT_HURT = 'red';//'#AAFF99FF';
	const SNAKE_COLOR_DARK_HURT = 'cyan';//'#AAFFAAFF';
	let nTrianglesRendered = 0;
	for(let y = 0; y < EnemySnake.SNAKE_MESH_HEIGHT-1; ++y)
	{
		for(let x = 0; x < EnemySnake.SNAKE_MESH_WIDTH-1; ++x)
		{
			let i = y*EnemySnake.SNAKE_MESH_WIDTH+x;
			let i1 = y*EnemySnake.SNAKE_MESH_WIDTH+x+1;	// rightward
			let j = (y+1)*EnemySnake.SNAKE_MESH_WIDTH + x;	// downward
			let j1 = (y+1)*EnemySnake.SNAKE_MESH_WIDTH + x+1;	// downward rightward
			
			ctx.fillStyle = this.get_triangle_color(nTrianglesRendered);
			ctx.beginPath();
			ctx.moveTo(this.bodyVertices[i].v.x, this.bodyVertices[i].v.y);
			ctx.lineTo(this.bodyVertices[i1].v.x, this.bodyVertices[i1].v.y);
			ctx.lineTo(this.bodyVertices[j1].v.x, this.bodyVertices[j1].v.y);
			ctx.fill();
			++nTrianglesRendered;
			
			ctx.fillStyle = this.get_triangle_color(nTrianglesRendered);
			ctx.beginPath();
			ctx.moveTo(this.bodyVertices[i].v.x, this.bodyVertices[i].v.y);
			ctx.lineTo(this.bodyVertices[j1].v.x, this.bodyVertices[j1].v.y);
			ctx.lineTo(this.bodyVertices[j].v.x, this.bodyVertices[j].v.y);
			ctx.fill();
			++nTrianglesRendered;
		}
	}
	
	// render snake head
	const noseLen = this.ropeSegLen*EnemySnake.NOSE_LEN_RATIO;
	let neckRight = this.neckRightConstraint.fixedPoint;
	let neckLeft = this.neckLeftConstraint.fixedPoint.subtract(neckRight).rotate(Math.PI/6).mult(Math.sqrt(3)/2).add(neckRight);
	let mid = this.headPos.add( this.headDirec.mult(noseLen) );	// tip of nose
	let leftDirec = this.headDirec.rotate(-Math.PI/2);
	
	let c1 = this.headPos.add(this.headDirec.mult(noseLen*0.5)).add(leftDirec.mult( this.ropeSegLen*0.5));
	let c2 = this.headPos.add(this.headDirec.mult(noseLen    )).add(leftDirec.mult( this.ropeSegLen*0.4));
	let c3 = this.headPos.add(this.headDirec.mult(noseLen    )).add(leftDirec.mult(-this.ropeSegLen*0.4));
	let c4 = this.headPos.add(this.headDirec.mult(noseLen*0.5)).add(leftDirec.mult(-this.ropeSegLen*0.5));
	
	ctx.fillStyle = this.get_triangle_color(SNAKE_HEAD_PARAM);
	ctx.beginPath();
	ctx.moveTo(this.neckLeftConstraint.fixedPoint.x, this.neckLeftConstraint.fixedPoint.y);
	ctx.lineTo(neckLeft.x, neckLeft.y);
	ctx.bezierCurveTo(c1.x, c1.y, c2.x, c2.y, mid.x, mid.y);
	ctx.bezierCurveTo(c3.x, c3.y, c4.x, c4.y, neckRight.x, neckRight.y);
	ctx.fill();
	
	// render snake eyes
	let eyeWhite1 = this.headPos.add(this.headDirec.mult(noseLen*0.8 )).add(leftDirec.mult( this.ropeSegLen*0.28));
	let eyeWhite2 = this.headPos.add(this.headDirec.mult(noseLen*0.8 )).add(leftDirec.mult(-this.ropeSegLen*0.28));
	let eyeBlack1 = this.headPos.add(this.headDirec.mult(noseLen*0.83)).add(leftDirec.mult( this.ropeSegLen*0.28));
	let eyeBlack2 = this.headPos.add(this.headDirec.mult(noseLen*0.83)).add(leftDirec.mult(-this.ropeSegLen*0.28));
	eyeWhite1.render_solid('white', this.ropeSegLen*0.21);
	eyeWhite2.render_solid('white', this.ropeSegLen*0.21);
	eyeBlack1.render_solid('black', this.ropeSegLen*0.15);
	eyeBlack2.render_solid('black', this.ropeSegLen*0.15);
	
	// debug render stick constraints
	this.constraints.filter(c => c instanceof ConstraintStick).forEach(c => {
		//new LineSeg(c.vc0.v, c.vc1.v).render(c.colorStr);
	});
	
	// debug render neck left
	const START_VERTEX_COLOR = 'green';
	//startPosConstraint.fixedPoint.render_solid(START_VERTEX_COLOR, VERTEX_RADIUS);
	
	// debug render neck right
	const END_VERTEX_COLOR = 'red';
	//endPosConstraint.fixedPoint.render_solid(END_VERTEX_COLOR, VERTEX_RADIUS);
	
	// debug render waypoint
	const WAYPOINT_COLOR = 'yellow';
	//this.waypoint.render_ring(WAYPOINT_COLOR, 20);
}

// constructor
function Bullet(pos, vel, radius)
{
	MovingParticle.call(this, pos, vel, radius);
}
Bullet.prototype = Object.create(MovingParticle.prototype);

Bullet.prototype.render = function()
{
	let gc = this.pos.add(new vec2(0.5, -0.5).mult(this.radius));	// gradient center
	let gradient = ctx.createRadialGradient(gc.x, gc.y, 0, gc.x, gc.y, 2*this.radius);
	gradient.addColorStop(0, '#B2A7A0');
	gradient.addColorStop(0.15, '#7C7570');
	gradient.addColorStop(.5, '#4f453f');
	gradient.addColorStop(1, '#3c3b3b');
	this.pos.render_solid(gradient, this.radius);
}

// constructor
// sinusoidally bobbing back and forth around equilibTheta with angular amplitude, with angular frequency omega, starting at phase theta0
function GrassBlade(rootPos, bladeLen, theta0, omega, amplitude, equilibTheta, colorStr)
{
	Particle.call(this);
	this.rootPos = rootPos;	// vec2
	this.bladeLen = bladeLen;
	this.inTheta = theta0;	// increases linearly over time
	this.omega = omega;
	this.equilibTheta = equilibTheta;
	this.amplitude = amplitude;
	this.colorStr = colorStr;
}
GrassBlade.prototype = Object.create(Particle.prototype);

GrassBlade.prototype.is_dead = () => false;

GrassBlade.prototype.get_y_priority = function()
{
	return this.rootPos.y;
}

GrassBlade.prototype.update = function()
{
	this.inTheta += this.omega;
}

GrassBlade.prototype.render = function()
{
	const PERPENDICULAR_SHRINK = 0.125;
	let outTheta = this.amplitude * Math.cos(this.inTheta);
	let lengthwise = new vec2(this.bladeLen, 0).rotate(this.equilibTheta + outTheta);
	let tip = this.rootPos.add(lengthwise);
	let perp = lengthwise.rotate(Math.PI/2).mult(PERPENDICULAR_SHRINK);	// blade of grass is thinner rather than fatter
	let c1 = this.rootPos.add(lengthwise.mult(1/6)).add(perp);
	let c2 = this.rootPos.add(lengthwise.mult(1/2)).add(perp);
	let c3 = this.rootPos.add(lengthwise.mult(1/2)).add(perp.mult(-1));
	let c4 = this.rootPos.add(lengthwise.mult(1/6)).add(perp.mult(-1));
	
	ctx.fillStyle = this.colorStr;
	ctx.beginPath();
	ctx.moveTo(this.rootPos.x, this.rootPos.y);
	ctx.bezierCurveTo(c1.x, c1.y, c2.x, c2.y,          tip.x,          tip.y);
	ctx.bezierCurveTo(c3.x, c3.y, c4.x, c4.y, this.rootPos.x, this.rootPos.y);
	ctx.fill();
}

// constructor
function SmokePuff(pos, vel, radius, rgbColorStr, lifeTime)
{
	MovingParticle.call(this, pos, vel, radius);
	this.initRadius = radius;
	this.lifeTime = lifeTime;
	this.initLifeTime = lifeTime;
	this.rgbColorStr = rgbColorStr;
}
SmokePuff.prototype = Object.create(MovingParticle.prototype);

SmokePuff.prototype.is_dead = function()
{
	return this.lifeTime <= 0 || MovingParticle.prototype.is_dead.call(this);
}

SmokePuff.prototype.update = function()
{
	--this.lifeTime;
	MovingParticle.prototype.update.call(this);
}

SmokePuff.prototype.render = function()
{
	let invParam = this.lifeTime/this.initLifeTime;
	let param = 1 - invParam;
	let radius = (1-param**6)*this.initRadius;
	let color = `${this.rgbColorStr}${Math.floor(invParam*204).toString(16).padStart(2, '0')}`
	this.pos.render_solid(color, radius);
}

// constructor
// coin dropped by killed enemies
const COIN_STATE_COLLECTIBLE = 'COIN_STATE_COLLECTIBLE';
const COIN_STATE_EVAPORATING = 'COIN_STATE_EVAPORATING';
const COIN_LIFETIME_FRAMES = 300;
const COIN_EVAPORATE_DURATION_FRAMES = 30;
function Coin(pos, radius)
{
	MovingParticle.call(this, pos, new vec2(0, 0), radius);
	// this.radius == render radius
	this.animFrame = 0;	// integer in range [0, 6)
	this.creationFrame = frame;	// frame this Coin was created
	this.startPos = pos.clone();
	this.state = COIN_STATE_COLLECTIBLE;
	
	this.startEvaporateFrame;
	this.startEvaporateY;
}
Coin.prototype = Object.create(MovingParticle.prototype);

Coin.prototype.is_dead = function()
{
	if (this.state == COIN_STATE_COLLECTIBLE)
	{
		return frame >= this.creationFrame + COIN_LIFETIME_FRAMES || !this.isActive;	
	}
	else if(this.state == COIN_STATE_EVAPORATING)
	{
		return frame >= this.startEvaporateFrame + COIN_EVAPORATE_DURATION_FRAMES || !this.isActive;
	}
	throw new Error(`invalid coin state \"${this.state}\"`);
}

Coin.prototype.get_y_priority = function()
{
	return this.startPos.y + this.radius;
}

// begin evaporation; should only be called once per coin
Coin.prototype.evaporate = function()
{
	this.state = COIN_STATE_EVAPORATING;
	this.startEvaporateY = this.pos.y;
	this.startEvaporateFrame = frame;
}

const COIN_FRICTION = 0.80;
const MAX_COIN_SPEED = 2.7;
Coin.prototype.update = function()
{
	// move coin onscreen
	if (this.startPos.x < 0)
	{
		this.vel.x = MAX_COIN_SPEED;
	}
	if (this.startPos.x > CANVAS_WIDTH)
	{
		this.vel.x = -MAX_COIN_SPEED;
	}
	if (this.startPos.y < 0)
	{
		this.vel.y = MAX_COIN_SPEED;
	}
	if (this.startPos.y > CANVAS_HEIGHT)
	{
		this.vel.y = -MAX_COIN_SPEED;
	}
	this.startPos = this.startPos.add(this.vel);
	this.vel = this.vel.mult(COIN_FRICTION);
	this.pos.x = this.startPos.x;
	
	if (this.state == COIN_STATE_COLLECTIBLE)
	{
		const COIN_NUM_FRAMES_PER_ANIM_FRAME_HOVERING = 5;
		this.animFrame = Math.floor((frame - this.creationFrame)/COIN_NUM_FRAMES_PER_ANIM_FRAME_HOVERING) % 6;
		
		const COIN_MAX_HOVER_HEIGHT = 8.0;	// world coord units
		const COIN_HOVER_PERIOD_FRAMES = 99;
		this.pos.y = this.startPos.y - COIN_MAX_HOVER_HEIGHT*0.5*(1 - Math.cos((frame - this.creationFrame)*2*Math.PI/COIN_HOVER_PERIOD_FRAMES) );	// sinusoidal hovering
	}
	else if(this.state == COIN_STATE_EVAPORATING)
	{
		const COIN_NUM_FRAMES_PER_ANIM_FRAME_EVAPORATING = 1;
		this.animFrame = Math.floor((frame - this.startEvaporateFrame)/COIN_NUM_FRAMES_PER_ANIM_FRAME_EVAPORATING) % 6;
		
		const COIN_MAX_EVAPORATE_HEIGHT = 60;
		let param = (frame - this.startEvaporateFrame)/COIN_EVAPORATE_DURATION_FRAMES;
		this.pos.y = this.startEvaporateY - COIN_MAX_EVAPORATE_HEIGHT * param**0.5;
		
	}
	else
	{
		throw new Error(`invalid coin state \"${this.state}\"`);
	}
}

Coin.prototype.render = function()
{
	let alpha = 1.0;
	if (this.state == COIN_STATE_COLLECTIBLE)
	{
		const COIN_FADE_DURATION_FRAMES_HOVERING = 30;	// number of frames within lifetime that alpha fading occurs
		alpha = 1 - (frame - this.creationFrame - COIN_LIFETIME_FRAMES + COIN_FADE_DURATION_FRAMES_HOVERING)/COIN_FADE_DURATION_FRAMES_HOVERING;
	}
	else if(this.state == COIN_STATE_EVAPORATING)
	{
		const COIN_FADE_DURATION_FRAMES_EVAPORATING = 30;
		alpha = 1 - (frame - this.startEvaporateFrame - COIN_EVAPORATE_DURATION_FRAMES + COIN_FADE_DURATION_FRAMES_EVAPORATING)/COIN_FADE_DURATION_FRAMES_EVAPORATING;
	}
	else
	{
		throw new Error(`invalid coin state \"${this.state}\"`);
	}
	
	let srcRect = new Rect(this.animFrame*79, 0, 79, 79);
	let dstRect = new Rect(this.pos.x - this.radius, this.pos.y - this.radius, this.radius*2, this.radius*2);
	apply_image_precise(coinSheet, alpha, srcRect, dstRect);
}

const CURSOR_COIN_COLLECT_RADIUS = 30;
let nCoins = 0;
let nCoinsFinalScore = 0;

// constructor
function Camera()
{
	this.topLeft = new vec2(0, 0);	// vec2; world coords
	this.topLeftDst = new vec2(0, 0);	// vec2; world coords
	this.zoomExpon = 0.0;	// multiplicative zoom factor == 2^zoomExpon; camera width (in world coords) is CANVAS_WIDTH*2^-zoomExpon
	this.zoomExponDst = 0.0;
	this.startShakeFrame = 0;
	this.shakeDuration = 0;	// number of frames
	this.shakeAmplitude = 0;	// world units
	this.numFramesPerJolt = 1;
}

// internal zoom function
// adjust zoom exponent by arg
// worldFixedPos is world coords of point that transforms to same screen coords before/after zoom
// using world-to-screen transform, (f-t)*2^z == (f-t')*2^z', where
//		f is fixed point's world coords
//		t is world coords of topLeft before zoom
//		t' is world coords of topLeft after zoom
// then we solve for t' = f - (f-t)*2^z/2^z
const CAMERA_ZOOM_RATE = 0.07;
Camera.prototype.zoom = function(plusZoomExpon, worldFixedPos)
{
	this.zoomExponDst += plusZoomExpon;
	this.topLeftDst = worldFixedPos.subtract( worldFixedPos.subtract(this.topLeftDst).mult(2**-plusZoomExpon) );
}

// external-facing zoom function
Camera.prototype.zoom_in = function(screenFixedPos)
{
	this.zoom(CAMERA_ZOOM_RATE, screenFixedPos);
}

// external-facing zoom function
Camera.prototype.zoom_out = function(screenFixedPos)
{
	this.zoom(-CAMERA_ZOOM_RATE, screenFixedPos);
}

Camera.prototype.reset_camera = function()
{
	this.zoomExponDst = 0.0;
	this.topLeftDst.x = 0.0;
	this.topLeftDst.y = 0.0;
}

// return to default camera position/zoom in zero time
Camera.prototype.hard_reset_camera = function()
{
	this.reset_camera();
	this.topLeft.x = 0;
	this.topLeft.y = 0;
	this.zoomExpon = 0;
}

// deltaScreenCoords is vec2
// moves camera in the direct of deltaScreenCoords
Camera.prototype.pan = function(deltaScreenCoords)
{
	this.topLeftDst = this.topLeftDst.add(deltaScreenCoords.mult(2**-this.zoomExpon));
}

// load identity matrix into canvas context without changing camera position/zoom
Camera.prototype.set_identity_matrix = function()
{
	ctx.setTransform(1, 0, 0, 1, 0, 0);
}

Camera.prototype.set_transform_matrix = function()
{
	// matrix converts draw calls (world coords) to screen coords
	ctx.setTransform(2**this.zoomExpon, 0, 0, 2**this.zoomExpon, -this.topLeft.x*2**this.zoomExpon, -this.topLeft.y*2**this.zoomExpon);
}

// returns vec2 in world coords
Camera.prototype.screen_to_world_coords = function(screenPos)
{
	return screenPos.mult(2**-this.zoomExpon).add(this.topLeft);
}

// returns vec2 in screen coords
Camera.prototype.world_to_screen_coords = function(worldPos)
{
	return worldPos.subtract(this.topLeft).mult(2**this.zoomExpon);
}

Camera.prototype.update = function()
{
	// exponentially decay towards destination zoom & destination topLeft
	const PAN_DECAY_FACTOR = 0.87;
	this.topLeft = this.topLeftDst.add(this.topLeft.subtract(this.topLeftDst).mult(PAN_DECAY_FACTOR));
	
	const ZOOM_DECAY_FACTOR = 0.87;
	this.zoomExpon = this.zoomExponDst + (this.zoomExpon - this.zoomExponDst)*ZOOM_DECAY_FACTOR
	
	// shake camera
	if (frame < this.startShakeFrame + this.shakeDuration && frame % this.numFramesPerJolt == 0)
	{
		let theta = 2*Math.PI*Math.random();
		this.topLeft = this.topLeft.add( new vec2( this.shakeAmplitude*Math.cos(theta), this.shakeAmplitude*Math.sin(theta) ) );
	}
}

// request shaking camera topLeftDst for shakeDuration frames with radial amplitude (in world units) before decaying back to normal camera position
Camera.prototype.start_shake = function(shakeDuration, amplitude, numFramesPerJolt)
{
	this.startShakeFrame = frame;
	this.shakeDuration = shakeDuration;
	this.shakeAmplitude = amplitude;
	this.numFramesPerJolt;
}

Camera.prototype.stop_shake = function()
{
	this.startShakeFrame = -1;
	this.shakeDuration = 0;
}

let camera = new Camera();
let lastCannonHurtFrame = -99999;
const CANNON_HURT_DURATION = 120;	// flashing invincibility duration frames
const CANNON_FLASH_PERIOD = 20.4;	// duration in frames
let cannonHealth;	// number of hits that cannon can take before game over

// let crab = load_image('crabBitmap.png');
let crab = load_image('https://rexdragin59.github.io/circledefense/crabBitmap.png');
// let crabClawUpper = load_image('crab claw upper bitmap.png');
let crabClawUpper = load_image('https://rexdragin59.github.io/circledefense/crab claw upper bitmap.png');
// let crabClawLower = load_image('crab claw lower bitmap.png');
let crabClawLower = load_image('https://rexdragin59.github.io/circledefense/crab claw lower bitmap.png');
// let crabClawWhole = load_image('crab claw whole bitmap.png');
let crabClawWhole = load_image('https://rexdragin59.github.io/circledefense/crab claw whole bitmap.png');
// let frogStand = load_image('frogStand.png');
let frogStand = load_image('https://rexdragin59.github.io/circledefense/frogStand.png');
// let frogHurtStand = load_image('frogHurtStand.png');
let frogHurtStand = load_image('https://rexdragin59.github.io/circledefense/frogHurtStand.png');
// let frogJump = load_image('frogJump.png');
let frogJump = load_image('https://rexdragin59.github.io/circledefense/frogJump.png');
// let frogHurtJump = load_image('frogHurtJump.png');
let frogHurtJump = load_image('https://rexdragin59.github.io/circledefense/frogHurtJump.png');
// let frogStandShadow = load_image('frogStandShadow.png');
let frogStandShadow = load_image('https://rexdragin59.github.io/circledefense/frogStandShadow.png');
// let frogJumpShadow = load_image('frogJumpShadow.png');
let frogJumpShadow = load_image('https://rexdragin59.github.io/circledefense/frogJumpShadow.png');
// let coinSheet = load_image('coinSheet.png');
let coinSheet = load_image('https://rexdragin59.github.io/circledefense/coinSheet.png');
// let heartButt = load_image('heartButt.png');
let heartButt = load_image('https://rexdragin59.github.io/circledefense/heartButt.png');

// draws arg img such that the lineSeg (pic0, pic1) treated as world coords, lines up exactly with [the lineSeg (dst0, dst1) in world coords]
// reflects images about lineSeg iff boolean arg mustReflect is true
// can specify srcRect (Rect object) to render rectangle-clipped source instead of entire source
function draw_image_align_line_segs(img, pic0, dst0, pic1, dst1, mustReflect = false, srcRect = undefined)
{
	if (vec2.is_same_loc(pic0, pic1))
	{
		throw new Error('stretch src picture infinitely to match dst0&dst1 markers');
	}
	
	let m = ctx.getTransform();
	let deltaPic = pic1.subtract(pic0);
	let deltaDst = dst1.subtract(dst0);
	let thetaPic = Math.atan2(deltaPic.y, deltaPic.x);
	let thetaDst = Math.atan2(deltaDst.y, deltaDst.x);
	
	// apply transformation in reverse, since transformation matrix is right-multiplied by new transformations, like in openGL
	// Transformation: 	Translate so that pic0 is at origin.
	//		Then rotate src img so that pic0&pic1 lineSeg is aligned with positive x-axis, then reflect about x-axis if needed.
	//		Then scale to correct scale. Then rotate so that pic0&pic1 lineSeg is parallel with dst0&dst1 lineseg.
	//		Finally, translate pic0 (at origin) to dst0.
	ctx.translate(dst0.x, dst0.y);
	ctx.rotate(thetaDst);
	let scaleFactor = deltaDst.len()/deltaPic.len();
	ctx.scale(scaleFactor, scaleFactor);
	if (mustReflect)
	{
		ctx.transform(1, 0, 0, -1, 0, 0);
	}
	ctx.rotate(-thetaPic);
	ctx.translate(-pic0.x, -pic0.y);
	
	if (srcRect)	// clip source Rect if needed
	{
		let alpha = 1.0;
		let dstRect = new Rect(0, 0, srcRect.w, srcRect.h);
		apply_image_precise(img, alpha, srcRect, dstRect);
	}
	else
	{	// otherwise render entire src img
		apply_image(img, 0, 0);
	}
	ctx.setTransform(m.a, m.b, m.c, m.d, m.e, m.f);		// reset transformation matrix
}

// load for future use but do not play right now
function load_sound_from_file(path)
{
	let audio = new Audio(path);
}

function play_sound_from_file(path)
{
	let audio = new Audio(path);
	audio.addEventListener('loadeddata', function(){
		audio.play();
	});
}

// let thudSoundPath = 'thud2.wav';
let thudSoundPath = 'https://rexdragin59.github.io/circledefense/thud2.wav';
// let snareSoundPath = 'snare.wav';
let snareSoundPath = 'https://rexdragin59.github.io/circledefense/snare.wav';
// let spitSoundPath = 'spit.wav';
let spitSoundPath = 'https://rexdragin59.github.io/circledefense/spit.wav';//'spit.wav';
// let coinSoundPath = 'coinClink.wav';
let coinSoundPath = 'https://rexdragin59.github.io/circledefense/coinClink.wav';
//let birdSoundPath = 'birdSongs.mp3';
let birdSoundPath = 'https://rexdragin59.github.io/circledefense/birdSongs.mp3';
let birdAudio;	// Audio object
// let tapSoundPath = 'tap.wav';
let tapSoundPath = 'https://rexdragin59.github.io/circledefense/tap.wav';

try
{
	load_sound_from_file(thudSoundPath);
	load_sound_from_file(snareSoundPath);
	load_sound_from_file(spitSoundPath);
	load_sound_from_file(coinSoundPath);
	load_sound_from_file(tapSoundPath);
	load_sound_from_file(birdSoundPath);
}
catch(e)
{
	throw e.message;
}

const MUSIC_PLAY = 'MUSIC_PLAY';
const MUSIC_PAUSE = 'MUSIC_PAUSE';
function set_music_pause_play(musicPausePlay)
{
	if (birdAudio && birdAudio.isLoaded)
	{
		if (musicPausePlay == MUSIC_PLAY)
		{
			birdAudio.play();
		}
		else if(musicPausePlay == MUSIC_PAUSE)
		{
			birdAudio.pause();
		}
		else
		{
			throw new Error(`invalid musicPausePlay arg: ${musicPausePlay}`);
		}
	}
}

function toggle_music_pause_play()
{
	if (birdAudio && birdAudio.isLoaded)
	{
		if (birdAudio.paused)
		{
			birdAudio.play();
		}
		else
		{
			birdAudio.pause();
		}
	}
}


const GAME_STATE_UPGRADE = 'GAME_STATE_UPGRADE';
const GAME_STATE_PLAYING = 'GAME_STATE_PLAYING';
const GAME_STATE_START = 'GAME_STATE_START';
const GAME_STATE_RESTART = 'GAME_STATE_RESTART';
let gameState = GAME_STATE_START;


const BUTTON_STATE_OFF = 'BUTTON_STATE_OFF';	// mouse not over
const BUTTON_STATE_OVER = 'BUTTON_STATE_OVER';
const BUTTON_STATE_DOWN = 'BUTTON_STATE_DOWN';

// returns boolean whether circle with center (vec2) and radius contains point (vec2)
function does_circle_contain_point(circleCenter, circleRadius, point, isBorderIncluded = true)
{
	if (isBorderIncluded)
	{
		return circleCenter.subtract(point).len_sq() <= circleRadius*circleRadius;
	}
	return circleCenter.subtract(point).len_sq() < circleRadius*circleRadius;
}

// constructor
// rect (x, y, w, h) can be in world or screen (or any other system of) coords, so long as args passed to handle_mouse_* are also in same coords sys
function Button(x, y, w, h, roundCornerRadius, offColor, overColor, downColor, strokeColor)
{
	Rect.call(this, x, y, w, h);
	if (roundCornerRadius > w/2)
	{
		roundCornerRadius = w/2;
	}
	
	if (roundCornerRadius > h/2)
	{
		roundCornerRadius = h/2;
	}
	this.r = roundCornerRadius;
	this.state = BUTTON_STATE_OFF;
	this.offColor = offColor;
	this.overColor = overColor;
	this.downColor = downColor;
	this.strokeColor = strokeColor;
	this.hasClickedDown = false;	// Boolean whether mouse has clicked down on this button
}
Button.prototype = Object.create(Rect.prototype);

// returns boolean whether arg point is within button's clickable region
Button.prototype.contains_vec2 = function(point)
{
	if (!Rect.prototype.contains_vec2.call(this, point))
	{
		return false;
	}
	
	// check to see if clicked inside rounded corners
	let corners = [{rect: new Rect(this.x,               this.y,               this.r, this.r), c: new vec2(this.x+this.r,        this.y+this.r)},
				   {rect: new Rect(this.x+this.w-this.r, this.y,               this.r, this.r), c: new vec2(this.x+this.w-this.r, this.y+this.r)},
				   {rect: new Rect(this.x+this.w-this.r, this.y+this.h-this.r, this.r, this.r), c: new vec2(this.x+this.w-this.r, this.y+this.h-this.r)},
				   {rect: new Rect(this.x,               this.y+this.h-this.r, this.r, this.r), c: new vec2(this.x+this.r,        this.y+this.h-this.r)}];
	return !corners.some(corner => corner.rect.contains_vec2(point) && !does_circle_contain_point(corner.c, this.r, point) );
}

// must return Boolean whether this button continues existing && is visible after clicking
Button.prototype.onclick = function()
{
	throw new Error('must override pure virtual method Button.onclick()');
}

Button.prototype.handle_mouse_down = function(mouseLoc)
{
	if (this.contains_vec2(mouseLoc))
	{
		this.state = BUTTON_STATE_DOWN;
		this.hasClickedDown = true;
	}
}

Button.prototype.handle_mouse_motion = function(mouseLoc, isMouseDown)
{
	if (this.contains_vec2(mouseLoc))
	{
		if (this.hasClickedDown)
		{
			this.state = BUTTON_STATE_DOWN; // need only check for button_down and button_over states; all others outcomes of handle_motion are button_off
		}
		else if(!isMouseDown)
		{
			this.state = BUTTON_STATE_OVER;
		}
		else
		{
			this.state = BUTTON_STATE_OFF;
		}
	}
	else
	{
		this.state = BUTTON_STATE_OFF;
	}
}

Button.prototype.handle_mouse_up = function(mouseLoc)
{
	if (this.hasClickedDown && this.contains_vec2(mouseLoc))
	{
		this.onclick();
		this.state = BUTTON_STATE_OVER;
	}
	else
	{
		this.state = BUTTON_STATE_OFF;
	}
	this.hasClickedDown = false;
}

Button.prototype.render = function()
{
	if (this.state == BUTTON_STATE_OFF)
	{
		ctx.fillStyle = this.offColor;
	}
	else if(this.state == BUTTON_STATE_OVER)
	{
		ctx.fillStyle = this.overColor;
	}
	else if(this.state == BUTTON_STATE_DOWN)
	{
		ctx.fillStyle = this.downColor;
	}
	else
	{
		throw new Error(`invalid button state: ${this.state}`);
	}
	ctx.strokeStyle = this.strokeColor;	
	
	// render rounded rectangle
	ctx.beginPath();
	ctx.moveTo(this.x + this.r, this.y);
	ctx.lineTo(this.x + this.w - this.r, this.y);
	ctx.arcTo(this.x + this.w, this.y, this.x + this.w, this.y + this.r, this.r); // (xControl, yControl, xDst, yDst, radius)
	ctx.lineTo(this.x + this.w, this.y + this.h - this.r);
	ctx.arcTo(this.x + this.w, this.y + this.h, this.x + this.w - this.r, this.y + this.h, this.r);
	ctx.lineTo(this.x + this.r, this.y + this.h);
	ctx.arcTo(this.x, this.y + this.h, this.x, this.y - this.r, this.r);
	ctx.lineTo(this.x, this.y + this.r);
	ctx.arcTo(this.x, this.y, this.x + this.r, this.y, this.r);
	ctx.stroke();
	ctx.fill();
}

// constuctor
function StartGameButton()
{
	let x = 20.1, y = 100, w = 160, h = 120;
	let buttonRoundCornerRadius = 18.5;
	let buttonOffColor = '#FF000080';
	let buttonOverColor = '#0000FF80';
	let buttonDownColor = '#00FF0080';
	let buttonStrokeColor = 'black';
	Button.call(this, x, y, w, h, buttonRoundCornerRadius, buttonOffColor, buttonOverColor, buttonDownColor, buttonStrokeColor);
}
StartGameButton.prototype = Object.create(Button.prototype);

StartGameButton.prototype.onclick = function()
{
	game.play_next_level();	// calling game.play_next_level() is ignored if birdAudio not loaded
}

// constructor
function UpgradeForksButton()
{
	let x = CANVAS_WIDTH/5, y = CANVAS_HEIGHT*2/3, w = CANVAS_WIDTH/10, h = CANVAS_HEIGHT/10;
	let buttonRoundCornerRadius = 18.5;
	let buttonOffColor = '#FF000080';
	let buttonOverColor = '#0000FF80';
	let buttonDownColor = '#00FF0080';
	let buttonStrokeColor = 'black';
	Button.call(this, x, y, w, h, buttonRoundCornerRadius, buttonOffColor, buttonOverColor, buttonDownColor, buttonStrokeColor);
}
UpgradeForksButton.prototype = Object.create(Button.prototype);

// whether upgrade is available, regardless of how much money is on hand
UpgradeForksButton.prototype.can_upgrade = function()
{
	return nCannonBulletForks < 7;
}

let nCannonBulletForks = 1;
UpgradeForksButton.prototype.onclick = function()
{
	if (this.can_upgrade() && nCoins >= nCannonBulletForks*3)
	{
		nCoins -= nCannonBulletForks*3;
		++nCannonBulletForks;
	}
}

UpgradeForksButton.prototype.render = function()
{
	Button.prototype.render.call(this);	
	ctx.font = "20px Courier New";
	ctx.fillStyle = '#FFFFFFFF';
	ctx.fillText(`# forks: ${nCannonBulletForks}`, this.x, this.y + this.h + 20);
	ctx.fillText(`cost: ${this.can_upgrade() ? `${nCannonBulletForks*3} coins` : '---'}`, this.x, this.y + this.h + 40);
}

// constructor
function UpgradeReloadButton()
{
	let x = CANVAS_WIDTH/5, y = CANVAS_HEIGHT*1/3, w = CANVAS_WIDTH/10, h = CANVAS_HEIGHT/10;
	let buttonRoundCornerRadius = 18.5;
	let buttonOffColor = '#FF000080';
	let buttonOverColor = '#0000FF80';
	let buttonDownColor = '#00FF0080';
	let buttonStrokeColor = 'black';
	Button.call(this, x, y, w, h, buttonRoundCornerRadius, buttonOffColor, buttonOverColor, buttonDownColor, buttonStrokeColor);
}
UpgradeReloadButton.prototype = Object.create(Button.prototype);

// whether upgrade is available, regardless of how much money is on hand
UpgradeReloadButton.prototype.can_upgrade = function()
{
	return cannonReloadDuration > 11;
}

const CANNON_INITIAL_RELOAD_FRAMES = 30;
let cannonReloadDuration = 0;
UpgradeReloadButton.prototype.onclick = function()
{
	if (this.can_upgrade() && nCoins >= 10)
	{
		nCoins -= 10;
		cannonReloadDuration -= 3;
	}
}

UpgradeReloadButton.prototype.render = function()
{
	Button.prototype.render.call(this);	
	ctx.font = "20px Courier New";
	ctx.fillStyle = '#FFFFFFFF';
	ctx.fillText(`shot delay: ${cannonReloadDuration} frames`, this.x, this.y + this.h + 20);
	ctx.fillText(`cost: ${this.can_upgrade() ? '10 coins' : '---'}`, this.x, this.y + this.h + 40);
}

// constructor
const BULLET_INITIAL_SPEED = 2.7;
let bulletSpeed = 0;
function UpgradeShotSpeedButton()
{
	let x = CANVAS_WIDTH*3/5, y = CANVAS_HEIGHT*1/3, w = CANVAS_WIDTH/10, h = CANVAS_HEIGHT/10;
	let buttonRoundCornerRadius = 18.5;
	let buttonOffColor = '#FF000080';
	let buttonOverColor = '#0000FF80';
	let buttonDownColor = '#00FF0080';
	let buttonStrokeColor = 'black';
	Button.call(this, x, y, w, h, buttonRoundCornerRadius, buttonOffColor, buttonOverColor, buttonDownColor, buttonStrokeColor);
}
UpgradeShotSpeedButton.prototype = Object.create(Button.prototype);

// whether upgrade is available, regardless of how much money is on hand
UpgradeShotSpeedButton.prototype.can_upgrade = function()
{
	return bulletSpeed < 10;
}

UpgradeShotSpeedButton.prototype.onclick = function()
{
	if (this.can_upgrade() && nCoins >= 4)
	{
		nCoins -= 4;
		bulletSpeed += 0.5;
	}
}

UpgradeShotSpeedButton.prototype.render = function()
{
	Button.prototype.render.call(this);	
	ctx.font = "20px Courier New";
	ctx.fillStyle = '#FFFFFFFF';
	ctx.fillText(`shot speed: ${bulletSpeed}`, this.x, this.y + this.h + 20);
	ctx.fillText(`cost: ${this.can_upgrade() ? '4 coins' : '---'}`, this.x, this.y + this.h + 40);
}

// constructor
const BULLET_INITIAL_ATK_POWER = 1.0;	// damage dealt per bullet
let bulletAtkPower = 0;
function UpgradeBulletAtkPowerButton()
{
	let x = CANVAS_WIDTH*3/5, y = CANVAS_HEIGHT*2/3, w = CANVAS_WIDTH/10, h = CANVAS_HEIGHT/10;
	let buttonRoundCornerRadius = 18.5;
	let buttonOffColor = '#FF000080';
	let buttonOverColor = '#0000FF80';
	let buttonDownColor = '#00FF0080';
	let buttonStrokeColor = 'black';
	Button.call(this, x, y, w, h, buttonRoundCornerRadius, buttonOffColor, buttonOverColor, buttonDownColor, buttonStrokeColor);
}
UpgradeBulletAtkPowerButton.prototype = Object.create(Button.prototype);

// whether upgrade is available, regardless of how much money is on hand
UpgradeBulletAtkPowerButton.prototype.can_upgrade = function()
{
	return bulletAtkPower < 3;
}

UpgradeBulletAtkPowerButton.prototype.onclick = function()
{
	if (this.can_upgrade() && nCoins >= 7)
	{
		nCoins -= 7;
		bulletAtkPower += 0.2;
	}
}

UpgradeBulletAtkPowerButton.prototype.render = function()
{
	Button.prototype.render.call(this);	
	ctx.font = "20px Courier New";
	ctx.fillStyle = '#FFFFFFFF';
	ctx.fillText(`atk: ${bulletAtkPower}`, this.x, this.y + this.h + 20);
	ctx.fillText(`cost: ${this.can_upgrade() ? '7 coins' : '---'}`, this.x, this.y + this.h + 40);
}

// constructor
function FinishedUpgradesButton()
{
	let x = CANVAS_WIDTH*4/5, y = CANVAS_HEIGHT*1/3, w = CANVAS_WIDTH/10, h = CANVAS_HEIGHT/10;
	let buttonRoundCornerRadius = 5.0;
	let buttonOffColor = '#FF000080';
	let buttonOverColor = '#0000FF80';
	let buttonDownColor = '#00FF0080';
	let buttonStrokeColor = 'black';
	Button.call(this, x, y, w, h, buttonRoundCornerRadius, buttonOffColor, buttonOverColor, buttonDownColor, buttonStrokeColor);
}
FinishedUpgradesButton.prototype = Object.create(Button.prototype);

FinishedUpgradesButton.prototype.onclick = function()
{
	game.play_next_level();
}

FinishedUpgradesButton.prototype.render = function()
{
	Button.prototype.render.call(this);	
	ctx.font = "20px Courier New";
	ctx.fillStyle = '#FFFFFFFF';
	ctx.fillText(`next level`, this.x, this.y + this.h + 20);
}

let activeButtons = [];	// Array of (subclasses of) Button

// returns valid enemySpawnTimelines
// comments begin with '//' at the beginning of the line
// values are comma-separated
// blank lines and comments are ignored
// Ends of levels must be on a single line and must be of the form 'LEVEL_*', where * is any string, or empty string is ok
function parse_enemy_spawn_script(src)
{
	let timelines = [];
	let currTimeline = [];
	const LEVEL_TERMINATOR = 'LEVEL_';
	
	src.split('\n').map((line, lineNum) => {
		if (line == '' || line.substring(0, 2) == '//')
		{
			return;	// ignore comments and blank lines
		}
		
		if (line.substring(0, LEVEL_TERMINATOR.length) == LEVEL_TERMINATOR)
		{
			currTimeline.sort((a, b) => a.spawnFrame - b.spawnFrame);
			timelines.push(currTimeline);
			currTimeline = [];
			
		}
		else
		{
			let words = line.split(',');
			if (words.length == 0)
			{
				throw new Error(`line ${lineNum+1} has no entries after splitting by comma: ^${line}$`);
			}
			if (words[0] == 'crab')
			{
				if (words.length != 2)
				{
					throw new Error(`line ${lineNum+1} crab has invalid number of commas: ^${line}$`);
				}
				let spawnFrame = Number(words[1]);
				if (words[1] == '' || isNaN(spawnFrame))
				{
					throw new Error(`line ${lineNum+1} invalid crab spawn time: ^${words[1]}$`);
				}
				currTimeline.push({enemyStr: 'crab', spawnFrame: spawnFrame});
			}
			else if (words[0] == 'frog')
			{
				if (words.length != 2)
				{
					throw new Error(`line ${lineNum+1} frog has invalid number of commas: ^${line}$`);
				}
				let spawnFrame = Number(words[1]);
				if (words[1] == '' || isNaN(spawnFrame))
				{
					throw new Error(`line ${lineNum+1} invalid frog spawn time: ^${words[1]}$`);
				}
				currTimeline.push({enemyStr: 'frog', spawnFrame: spawnFrame});
			}
			else if (words[0] == 'snake')
			{
				if (words.length != 2)
				{
					throw new Error(`line ${lineNum+1} frog has invalid number of commas: ^${line}$`);
				}
				let spawnFrame = Number(words[1]);
				if (words[1] == '' || isNaN(spawnFrame))
				{
					throw new Error(`line ${lineNum+1} invalid snake spawn time: ^${words[1]}$`);
				}
				currTimeline.push({enemyStr: 'snake', spawnFrame: spawnFrame});
			}
			else
			{
				throw new Error(`line ${lineNum+1} invalid creature: ^${words[0]}$`);
			}
		}
		// go to next line
	});
	
	if (currTimeline.length > 0)
	{
		throw new Error(`script does not end with \"${LEVEL_TERMINATOR}*\" terminator token!`);
	}
	
	return timelines;
}

let enemySpawnSrc = `//
snake,0
crab,100
crab,160
crab,220
crab,280
crab,340
crab,400
crab,460
crab,520
crab,580
crab,640
LEVEL_end0

crab,100
crab,152
frog,178
crab,204
crab,256
crab,308
crab,308
crab,360
crab,412
crab,464
crab,516
frog,542
crab,568
LEVEL_end1

crab,100
crab,152
crab,204
crab,256
crab,308
crab,360
crab,412
crab,464
crab,516
crab,568
crab,620
crab,672
crab,724
crab,776
crab,828
crab,880
crab,932
crab,984
crab,1036
crab,1088
crab,1140
crab,1296
frog,210
frog,517
frog,770
frog,812
frog,910
frog,1120
frog,1200
LEVEL_end2

frog,120
frog,240
frog,360
frog,420
frog,480
frog,560
frog,620
frog,720
frog,820
frog,920
frog,1020
frog,1130
frog,1140
frog,1150
frog,1160
frog,1260
frog,1360
frog,1460
frog,1560
frog,1590
crab,120
crab,240
crab,250
crab,260
crab,270
crab,370
crab,570
crab,670
crab,780
crab,890
crab,1000
crab,1010
crab,1120
crab,1240
crab,1250
crab,1370
crab,1470
crab,1570
crab,1670
crab,1780
crab,1890
LEVEL_end3
`;

let enemySpawnTimelines = parse_enemy_spawn_script(enemySpawnSrc);	// Array of [Array of {enemyStr: String denoting which enemy type, spawnFrame: frameNum} sorted from lowest .frameNum to highest .frameNum], one element for each level

let levelStartFrame = 0;
let currLevel = -1;
let nextEnemySpawnIndex = 0;
let levelCompleteFrame = undefined;	// first frame where all enemies have been killed; undefined if level is not yet complete

var game = {
	// set canvas and create Context
	
	setup: function(){
		canvas = document.getElementById("myCanvas");
		canvas.width = CANVAS_WIDTH;
		canvas.height = CANVAS_HEIGHT;
		ctx = canvas.getContext("2d");
		canvas.style.width = CANVAS_WIDTH.toString() + "px";
		canvas.style.height = CANVAS_HEIGHT.toString() + "px";
		calculate_canvas_corner();
		ctx.textBaseline = 'top';
		
		// handle mouse down
		window.addEventListener('mousedown', function(e){
			xMouse = e.clientX - xCanvas;
			yMouse = e.clientY - yCanvas;
			// handle mouse down here
			mouseDownLoc = new vec2(xMouse, yMouse);
			mouseDownLoc = camera.screen_to_world_coords(mouseDownLoc);
			activeButtons.forEach(bt => bt.handle_mouse_down(mouseLoc));
		}.bind(this));
		
		// handle mouse motion
		window.addEventListener('mousemove', function(e){
			xMouse = e.clientX - xCanvas;	// no need to add/subtract window.pageXOffset, because xCanvas already accounts for page offset
			yMouse = e.clientY - yCanvas;
			
			// handle mouse motion here
			mouseLoc.x = xMouse;
			mouseLoc.y = yMouse;
			mouseLoc = camera.screen_to_world_coords(mouseLoc);
			activeButtons.forEach(bt => bt.handle_mouse_motion(mouseLoc, Boolean(mouseDownLoc)));
		}.bind(this));
		
		// handle mouse release
		window.addEventListener('mouseup', function(e){
			xMouse = e.clientX - xCanvas;
			yMouse = e.clientY - yCanvas;
			// handle mouse up here
			mouseLoc.x = xMouse;
			mouseLoc.y = yMouse;
			mouseLoc = camera.screen_to_world_coords(mouseLoc);
			mouseDownLoc = undefined;
			activeButtons.forEach(bt => bt.handle_mouse_up(mouseLoc));
		}.bind(this));
		
		// handle touch start
		window.addEventListener('touchstart', function(e){
			e.preventDefault();	// don't pan/zoom screen
			let xMouse = e.touches[0].clientX - xCanvas;
			let yMouse = e.touches[0].clientY - yCanvas;
			// handle touchStart here
			mouseLoc.x = xMouse;
			mouseLoc.y = yMouse;
			mouseLoc = camera.screen_to_world_coords(mouseLoc);
			mouseDownLoc = new vec2(xMouse, yMouse);
			mouseDownLoc = camera.screen_to_world_coords(mouseDownLoc);
			activeButtons.forEach(bt => bt.handle_mouse_down(mouseLoc));
		}.bind(this), {passive: false});
		
		// handle touch move
		window.addEventListener('touchmove', function(e){
			e.preventDefault();	// don't pan/zoom screen
			let xMouse = e.touches[0].clientX - xCanvas;
			let yMouse = e.touches[0].clientY - yCanvas;
			// handle touchMove here
			mouseLoc.x = xMouse;
			mouseLoc.y = yMouse;
			mouseLoc = camera.screen_to_world_coords(mouseLoc);
			activeButtons.forEach(bt => bt.handle_mouse_motion(mouseLoc, true));
		}.bind(this), {passive: false});
		
		// handle touch end
		window.addEventListener('touchend', function(e){
			e.preventDefault();	// don't pan/zoom screen
			
			// handle touchEnd here
			mouseDownLoc = undefined;
			activeButtons.forEach(bt => bt.handle_mouse_up(mouseLoc));
		}.bind(this), {passive: false});
		
		// recalculate origin when zooming/scrolling
		window.addEventListener('scroll', function(e){
			calculate_canvas_corner();
		}.bind(this));
		window.addEventListener('zoom', function(e){
			calculate_canvas_corner();
		}.bind(this));
		
		const PAN_SPEED = 31.9;
		window.addEventListener('keydown', function(e){
			if(e.key == 'o')
			{
				debugFlailPaused = !debugFlailPaused;
				console.log('debug flail pause toggle; paused? ', debugFlailPaused ? 'yes' : 'no');
			}
			else if (gameState == GAME_STATE_PLAYING || gameState == GAME_STATE_UPGRADE)
			{
				if (e.key == 'p')
				{
					gamePaused = !gamePaused;
					mustImmediatePause = false;
					console.log('game pause toggle; paused? ', gamePaused ? 'yes' : 'no');
					if (gameState == GAME_STATE_PLAYING)
					{
						toggle_music_pause_play();	// do not play music while in upgrade screen
					}
				}
				else if(e.key == '.')
				{
					// advance 1 frame, then pause
					dstCameraRect = {x: 0, y: 0, w: CANVAS_WIDTH, h: CANVAS_HEIGHT};
					gamePaused = false;
					mustImmediatePause = true;
					console.log('advance 1 frame');
					set_music_pause_play(MUSIC_PAUSE);
				}
				else if(!gamePaused)
				{
					if (gameState == GAME_STATE_PLAYING) // only allow camera movements in unpaused playing state
					{
						if(e.key == '8')
						{
							camera.zoom_in(mouseLoc);
						}
						else if(e.key == '9')
						{
							camera.zoom_out(mouseLoc);
						}
						else if(e.key == '0')
						{
							camera.reset_camera();
						}
						else if(e.key == 'w')
						{
							camera.pan(new vec2(0, -PAN_SPEED));
						}
						else if(e.key == 's')
						{
							camera.pan(new vec2(0, +PAN_SPEED));
						}
						else if(e.key == 'a')
						{
							camera.pan(new vec2(-PAN_SPEED, 0));
						}
						else if(e.key == 'd')
						{
							camera.pan(new vec2(+PAN_SPEED, 0));
						}
						else if(e.key == 'e')
						{
							console.log(`world coords: (${mouseLoc.x}, ${mouseLoc.y})`);
						}
					} // end if gameState == playing
				} // end if !gamePaused
			}	// end if gameState == playing || gameState == upgrade
		}.bind(this));

		// load resources
		this.reset_game();
		
		birdAudio = new Audio(birdSoundPath);
		birdAudio.addEventListener('loadeddata', function(){
			birdAudio.isLoaded = true;
		});
		birdAudio.addEventListener('ended', function(){
			// loop to beginning
			birdAudio.currentTime = 0;
			birdAudio.play();
		});
		
		// load more things
	},
	
	update: function(){
		if (gameState == GAME_STATE_PLAYING && !gamePaused)
		{
			if (mustImmediatePause)
			{
				gamePaused = true;
			}
			
			// create enemy from timeline
			if (currLevel < enemySpawnTimelines.length)
			{
				let timeline = enemySpawnTimelines[currLevel];
				if (nextEnemySpawnIndex < timeline.length)
				{
					let spawn = timeline[nextEnemySpawnIndex];
					if (frame - levelStartFrame >= spawn.spawnFrame)
					{
						if (spawn.enemyStr == 'crab')
						{
							particleEngine.add_particle(EnemyCrab.create_random_crab());
						}
						else if(spawn.enemyStr == 'frog')
						{
							particleEngine.add_particle(EnemyFrog.create_random_frog());
						}
						else if(spawn.enemyStr == 'snake')
						{
							particleEngine.add_particle(EnemySnake.create_random_snake());
						}
						else
						{
							throw new Error(`invalid enemy type: ${spawn.enemyStr}`);
						}
						++nextEnemySpawnIndex;
					}
				}
			}
			
			// advance cannon recoil timer
			const CANNON_RECOIL_RECOVER_RATE = 0.93;
			cannonBarrelRecoilPos *= CANNON_RECOIL_RECOVER_RATE;	// exponentially decaying back to normal
			
			--cannonReloadFramesRemaining;
			if (cannonReloadFramesRemaining <= 0)
			{
				const CANNON_INITIAL_RECOIL_POS = 38;
				if (mouseDownLoc)
				{
					// fire again
					cannonBarrelRecoilPos = CANNON_INITIAL_RECOIL_POS;
					cannonReloadFramesRemaining = mouseDownLoc ? cannonReloadDuration : 0;
					
					const BULLET_RADIUS = 8.0;
					const BULLET_FORK_ARC = Math.PI/17.23;	// angle of arc of a single fork in adjacent bullets
					let direc0 = new vec2(mouseLoc.x - CANNON_X, mouseLoc.y - CANNON_Y);
					direc0 = vec2.is_same_loc(direc0, new vec2(0, 0)) ? new vec2(0, -1) : direc0;	// handle zero direction
					let bulletTheta0 = Math.atan2(direc0.y, direc0.x) - BULLET_FORK_ARC*(nCannonBulletForks-1)/2;
					for(let i = 0; i < nCannonBulletForks; ++i)
					{
						let direc = new vec2(1, 0).rotate(bulletTheta0 + BULLET_FORK_ARC*i);
						let bullet = new Bullet(new vec2(CANNON_X, CANNON_Y).add(direc.mult(CANNON_BASE_RADIUS)),	// bullet materializes some dist away from cannon base, not directly atop cannon base's center
												direc.mult(bulletSpeed), BULLET_RADIUS);
						particleEngine.add_particle(bullet);
					}
					play_sound_from_file(spitSoundPath);
				}
			}
			
			// check for collisions btwn bullets and enemies
			let bullets = particleEngine.particles.filter(p => p instanceof Bullet);
			let enemies = particleEngine.particles.filter(p => p instanceof Enemy);
			for(let e = 0; e < enemies.length; ++e)
			{
				for(let b = 0 ; b < bullets.length; ++b)
				{
					let e1 = enemies[e];
					let b1 = bullets[b];
					
					if (e1.is_colliding_with_moving_circle(b1))
					{
						b1.isActive = false;
						particleEngine.create_smoke_puffs(get_circle_collision_loc(b1.pos, e1.pos, b1.radius, e1.radius));
						bullets = bullets.slice(0, b).concat(bullets.slice(b+1));
						play_sound_from_file(tapSoundPath);
						
						// damage dealt to enemy
						e1.take_damage(bulletAtkPower);
						if (e1.is_dead())
						{
							e1.isActive = false;
							particleEngine.create_star_explosion(e1.pos);
							play_sound_from_file(thudSoundPath);
							
							const COIN_RADIUS = 20;
							particleEngine.add_particle(new Coin(e1.pos, COIN_RADIUS)); // drop coin
							enemies = enemies.slice(0, e).concat(enemies.slice(e+1));
						}
						
						break;	// skip to next bullet
					}
				}
			}
			
			// check for collision between enemy and cannon
			for(let e = 0; e < enemies.length; ++e)
			{
				let e1 = enemies[e];
				if ( e1.is_colliding_with_moving_circle( new MovingParticle(new vec2(CANNON_X, CANNON_Y), new vec2(0, 0), CANNON_BASE_RADIUS) ) )
				{
					// destroy enemy
					particleEngine.create_star_explosion(e1.pos);
					e1.isActive = false;
					enemies = enemies.slice(0, e).concat(enemies.slice(e+1));
					play_sound_from_file(thudSoundPath);

					if (frame >= lastCannonHurtFrame + CANNON_HURT_DURATION)
					{
						// enemy has hurt cannon
						play_sound_from_file(snareSoundPath);
						
						--cannonHealth;
						if (cannonHealth == 0)
						{
							game.reset_game(true);
							return;	// immediately abort, since running through the remaining enemy/cannon collisions are invalid
						}
						
						// Begin cannon flashing and camera shake
						lastCannonHurtFrame = frame;
						const CANNON_HURT_SHAKE_DURATION = 10;
						const CANNON_HURT_SHAKE_AMPLITUDE = 5;
						const CANNON_HURT_NUM_FRAMES_PER_JOLT = 2;
						camera.start_shake(CANNON_HURT_SHAKE_DURATION, CANNON_HURT_SHAKE_AMPLITUDE, CANNON_HURT_NUM_FRAMES_PER_JOLT);
					}
				}
			}
			
			// collect coins close to cursor
			particleEngine.particles.filter(p => p instanceof Coin && p.state == COIN_STATE_COLLECTIBLE).forEach(coin => {
				if (does_circle_contain_point(mouseLoc, CURSOR_COIN_COLLECT_RADIUS + coin.radius, coin.pos))
				{
					coin.evaporate();
					play_sound_from_file(coinSoundPath);
					++nCoins;
				}
			});
			
			// check for level completion
			if (levelCompleteFrame == undefined)
			{
				if (nextEnemySpawnIndex >= enemySpawnTimelines[currLevel].length && !particleEngine.particles.some(p => p instanceof Enemy))
				{
					levelCompleteFrame = frame;
				}
			}
			else	// check if it's time to transition to upgrade screen
			{
				const LEVEL_COMPLETE_WAIT_DURATION = 240;
				if (frame >= levelCompleteFrame + LEVEL_COMPLETE_WAIT_DURATION)
				{
					if (currLevel == enemySpawnTimelines.length - 1)
					{
						this.reset_game();
						return;
					}
					else
					{
						this.level_complete_open_upgrade_screen();
					}
				}
			}
			
			particleEngine.update();	// kill dead particles/bullets/enemies/coins/etc.
			
			// camera zoom/pan decay
			camera.update();
			
			// fps
			let currTime = new Date().getTime();
			if (frame % NUM_FRAMES_PER_FPS_UPDATE == 0)
			{
				document.getElementById("fpsDisplay").innerText = 'FPS: '.concat((1000/(currTime-prevFrameTime)).toFixed(1));
			}
			prevFrameTime = currTime;
			
			++frame;
		}
		
		if (!debugFlailPaused)
		{
			++debugFrame;
		}
	},

	render: function(){
		// clear screen
		ctx.setTransform(1, 0, 0, 1, 0, 0);	// load identity matrix
		ctx.fillStyle = "#404010FF";
		ctx.fillRect(0, 0, canvas.width, canvas.height);
		
		// set camera transform
		camera.set_transform_matrix();
		
		if (gameState == GAME_STATE_PLAYING)
		{
			// render particles
			particleEngine.render();
			
			// render cursor crosshair
			const CURSOR_RADIUS = 5;
			const CURSOR_COLOR = '#FFFF00FF';
			mouseLoc.render_ring(CURSOR_COLOR, CURSOR_RADIUS);
			new LineSeg(new vec2(mouseLoc.x, mouseLoc.y-2*CURSOR_RADIUS),
						new vec2(mouseLoc.x, mouseLoc.y+2*CURSOR_RADIUS)).render(CURSOR_COLOR);
			new LineSeg(new vec2(mouseLoc.x-2*CURSOR_RADIUS, mouseLoc.y),
						new vec2(mouseLoc.x+2*CURSOR_RADIUS, mouseLoc.y)).render(CURSOR_COLOR);
			new LineSeg(new vec2(CANNON_X, CANNON_Y), mouseLoc).render(CURSOR_COLOR);
			
			// render coin collect circle around cursor
			const COIN_COLLECT_CIRCLE_COLOR = '#A4A4A480';
			mouseLoc.render_ring(COIN_COLLECT_CIRCLE_COLOR, CURSOR_COIN_COLLECT_RADIUS);
			
			// render cannon base, flashing red if recently hurt
			const CANNON_BASE_COLOR = '#808090';
			const CANNON_RING_COLOR = '#223322';
			const CANNON_BASE_HURT_COLOR = '#B08090';
			const CANNON_RING_HURT_COLOR = '#623322';
			let isCannonRed = frame < lastCannonHurtFrame + CANNON_HURT_DURATION ? (frame % CANNON_FLASH_PERIOD < CANNON_FLASH_PERIOD/2) : false;
			let cannonBaseColor = isCannonRed ? CANNON_BASE_HURT_COLOR : CANNON_BASE_COLOR;
			let cannonRingColor = isCannonRed ? CANNON_RING_HURT_COLOR : CANNON_RING_COLOR;
			new vec2(CANNON_X, CANNON_Y).render_solid(cannonBaseColor, CANNON_BASE_RADIUS);
			new vec2(CANNON_X, CANNON_Y).render_ring (cannonRingColor, CANNON_BASE_RADIUS);
			
			// render cannon barrel
			ctx.fillStyle = cannonBaseColor;
			ctx.strokeStyle = cannonRingColor;
			ctx.beginPath();
			const BARREL_FRONT_DIAMETER = 15;
			const BARREL_REAR_DIAMETER = 20;
			const BARREL_NOZZLE_LENGTH = 40;
			const BARREL_RADIAL_OFFSET = 30;
			cannonTheta = Math.atan2(CANNON_X - mouseLoc.x, -(CANNON_Y - mouseLoc.y));	// angle in radians clockwise from positive y-axis
			let COS = Math.cos(cannonTheta);
			let SIN = Math.sin(cannonTheta);
			[new vec2( BARREL_FRONT_DIAMETER/2,  BARREL_NOZZLE_LENGTH/2 + BARREL_RADIAL_OFFSET - cannonBarrelRecoilPos),
			 new vec2( BARREL_REAR_DIAMETER /2, -BARREL_NOZZLE_LENGTH/2 + BARREL_RADIAL_OFFSET - cannonBarrelRecoilPos),
			 new vec2(-BARREL_REAR_DIAMETER /2, -BARREL_NOZZLE_LENGTH/2 + BARREL_RADIAL_OFFSET - cannonBarrelRecoilPos),
			 new vec2(-BARREL_FRONT_DIAMETER/2,  BARREL_NOZZLE_LENGTH/2 + BARREL_RADIAL_OFFSET - cannonBarrelRecoilPos),
			 undefined].forEach((v, i, arr) => {
				v = arr[i%4];	// wrap 4th to first vertex
				let x = v.x*COS - v.y*SIN;	// rotate cannon barrel to face cursor
				let y = v.x*SIN + v.y*COS;
				if (i == 0)
				{
					ctx.moveTo(x + CANNON_X, y + CANNON_Y);
				}
				else
				{
					ctx.lineTo(x + CANNON_X, y + CANNON_Y);
				}
			});
			ctx.stroke();
			ctx.fill();
			
			activeButtons.forEach(bt => bt.render());
			
			// render number of coins on hand
			this.render_coin_display();
			
			// render cannon health icons
			const CANNON_HEALTH_ICON_SPACING = 40;
			for(let i = cannonHealth-1; i >= 0; --i)
			{
				apply_image(heartButt, CANNON_X - CANNON_BASE_RADIUS + i*CANNON_HEALTH_ICON_SPACING, CANNON_Y + CANNON_BASE_RADIUS*1.2)
			}
			
			// render level start text
			const LEVEL_START_WAIT_DURATION = 180;
			if (frame - levelStartFrame < LEVEL_START_WAIT_DURATION)
			{
				ctx.font = '86px Courier New';
				ctx.fillStyle = '#FFFFFF';
				ctx.fillText(`LEVEL ${currLevel}`, 220, CANVAS_HEIGHT/2);
			}
			
			// render Level Complete text
			if (levelCompleteFrame != undefined)
			{
				ctx.font = '66px Courier New';
				ctx.fillStyle = '#FFFFFF';
				ctx.fillText('LEVEL COMPLETE', 100, CANVAS_HEIGHT/2);
				if (currLevel == enemySpawnTimelines.length - 1)
				{
					ctx.font = '26px Courier New';
					ctx.fillText('ALL LEVELS COMPLETE, returning to title screen', 20, CANVAS_HEIGHT*3/4);
				}
			}
			
			if (gamePaused)
			{
				this.render_pause_overlay();
			}
			
			// render other things
		}
		else if (gameState == GAME_STATE_UPGRADE)
		{
			// render active buttons
			activeButtons.forEach(bt => bt.render());
			
			// render number of coins on hand
			this.render_coin_display();
			
			camera.set_identity_matrix();
			ctx.font = "40px Courier New";
			ctx.fillStyle = '#FFFFFFFF';
			ctx.fillText('UPGRADE SCREEN', 50, 10);
			
			if (gamePaused)
			{
				this.render_pause_overlay();
			}
			camera.set_transform_matrix();
		}
		else if (gameState == GAME_STATE_START || gameState == GAME_STATE_RESTART)
		{
			ctx.font = "30px Courier New";
			ctx.fillStyle = '#FFFFFFFF';
			if (gameState == GAME_STATE_START)
			{
				ctx.fillText('CLICK BUTTON TO BEGIN PLAYING', 50, 10);
			}
			else
			{
				ctx.fillText('GAME OVER, CLICK BUTTON TO RESTART', 50, 10);
				ctx.fillText(`Your coin score: ${nCoinsFinalScore}`, 190, 110);
			}
			
			// render active buttons
			activeButtons.forEach(bt => bt.render());
		}
		
		// render other things
	},
	
	// renders at the same screen coords every time regardless of camera zoom/position
	render_coin_display: function()
	{
		camera.set_identity_matrix();
		ctx.font = "20px Courier New";
		ctx.fillStyle = '#FFFFFFFF';
		const COIN_DISPLAY_MINUS_X = 150;
		const COIN_DISPLAY_Y = 10;
		let coinStr = `coins: ${nCoins}`;
		ctx.fillText(coinStr, CANVAS_WIDTH - COIN_DISPLAY_MINUS_X, COIN_DISPLAY_Y);
		camera.set_transform_matrix();
	},
	
	// go to (or return to) start screen (from any state) and reload background grass
	reset_game: function(isGameOver = false)
	{
		if (birdAudio)
		{
			// game over screen; birdAudio already loadedbir
			birdAudio.pause();
			birdAudio.currentTime = 0;
		}
		
		particleEngine.reset_engine();
		activeButtons.splice(0);
		nCannonBulletForks = 1;
		cannonReloadDuration = CANNON_INITIAL_RELOAD_FRAMES;
		bulletSpeed = BULLET_INITIAL_SPEED;
		lastCannonHurtFrame = -99999;
		cannonHealth = 5;
		cannonReloadFramesRemaining = 0;
		bulletAtkPower = BULLET_INITIAL_ATK_POWER;
		camera.stop_shake();
		camera.hard_reset_camera();
		currLevel = -1;
		nextEnemySpawnIndex = 0;
		
		if (isGameOver)
		{
			gameState = GAME_STATE_RESTART;
			nCoinsFinalScore = nCoins;
		}
		else
		{
			gameState = GAME_STATE_START;
		}
		nCoins = 0;
		
		activeButtons.push(new StartGameButton());
	},
	
	// should only be called to go from gameState==playing to gameState==upgrade
	level_complete_open_upgrade_screen: function()
	{
		set_music_pause_play(MUSIC_PAUSE);
		activeButtons.splice(0);	// delete all existing buttons
		activeButtons.push(new UpgradeForksButton());
		activeButtons.push(new UpgradeReloadButton());
		activeButtons.push(new UpgradeShotSpeedButton());
		activeButtons.push(new UpgradeBulletAtkPowerButton());
		activeButtons.push(new FinishedUpgradesButton());
		particleEngine.reset_engine();
		gameState = GAME_STATE_UPGRADE;
	},
	
	// should only be called when gameState==start or gameState==restart or gameState==upgrade
	play_next_level: function()
	{
		// load grass blades
		const MIN_OMEGA = 0.02;
		const MAX_OMEGA = 0.05;
		const MIN_BLADE_LEN = 18;
		const MAX_BLADE_LEN = 38;
		const MIN_AMPLITUDE = Math.PI/14;
		const MAX_AMPLITUDE = Math.PI/10;
		const MIN_EQUILIB_THETA = Math.PI*4/3;
		const MAX_EQUILIB_THETA = Math.PI*5/3;
		const NUM_GRASS_CLUMPS = 200;
		const MIN_NUM_BLADES_PER_CLUMP = 3;
		const MAX_NUM_BLADES_PER_CLUMP = 3;
		const MAX_CLUMP_DIST_OFFSET = 14.56;
		for(let i = 0; i < NUM_GRASS_CLUMPS; ++i)
		{
			let numBlades = Math.floor(lerp(MIN_NUM_BLADES_PER_CLUMP, MAX_NUM_BLADES_PER_CLUMP+1, Math.random()));
			let clumpRootPos = new vec2( lerp(0, CANVAS_WIDTH, Math.random()), lerp(0, CANVAS_HEIGHT, Math.random()) );
			for(let j = 0; j < numBlades; ++j)
			{
				let omega = lerp(MIN_OMEGA, MAX_OMEGA, Math.random());
				let bladeRootPos = clumpRootPos.add(new vec2(MAX_CLUMP_DIST_OFFSET*(2*Math.random()-1), MAX_CLUMP_DIST_OFFSET*(2*Math.random()-1)));	// grass blades nearby but not bullseye-ing clump's root
				let bladeLen = lerp(MIN_BLADE_LEN, MAX_BLADE_LEN, Math.random());
				let theta0 = Math.random()*2*Math.PI;
				let amplitude = lerp(MIN_AMPLITUDE, MAX_AMPLITUDE, Math.random());
				let equilibTheta = lerp(MIN_EQUILIB_THETA, MAX_EQUILIB_THETA, Math.random());
				let color = `hsl(${lerp(88, 132, Math.random())}, 100%, ${rnd_btwn(20, 35)}%, 100%)`;
				let grassBlade = new GrassBlade(bladeRootPos, bladeLen, theta0, omega, amplitude, equilibTheta, color);
				particleEngine.add_particle(grassBlade);
			}
		}
	
		set_music_pause_play(MUSIC_PLAY);
		activeButtons.splice(0);	// delete all existing buttons
		++currLevel;
		nextEnemySpawnIndex = 0;
		levelCompleteFrame = undefined;
		gameState = GAME_STATE_PLAYING;
		levelStartFrame = frame;
	},
	
	render_pause_overlay: function()
	{
		camera.set_identity_matrix();
		const PAUSE_SCREEN_COLOR = '#000000B0';
		ctx.fillStyle = PAUSE_SCREEN_COLOR;
		ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
		
		const PAUSE_SCREEN_TEXT_COLOR = '#EEFFEEFF';
		ctx.font = '80px Courier New';
		let pauseText = 'GAME PAUSED';
		ctx.fillStyle = PAUSE_SCREEN_TEXT_COLOR;
		ctx.fillText(pauseText, CANVAS_WIDTH/2 - ctx.measureText(pauseText).width/2, CANVAS_HEIGHT/2);
		camera.set_transform_matrix();
	},
	
	gameLoop: function(){
		try
		{
			this.update();
			this.render();
		}
		catch(e)
		{
			document.getElementById('errorMarquee').innerText = `^${e.message}$`;	// for mobile-friendly debugging
			throw e;
		}
	},
		
	run: function(){
		// execute frame logic and render at a rate of 60 FPS
		window.setInterval(this.gameLoop.bind(this), 1000/FPS);
	},
};

function startGame(){
	try
	{
		console.log("game started");
		game.setup();
		game.run();
	}
	catch(e)
	{
		document.getElementById('errorMarquee').innerText = e.message;
		throw e;
	}
}

document.getElementById('errorMarquee').innerText = 'Compile success';	// for mobile-friendly debugging
</script>
</body>
</html>
